

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lecture Script &mdash; Robotic Python Library 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=01f34227"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="robotic python API" href="../api.html" />
    <link rel="prev" title="Extension - Gym Environment Interface: minimal example" href="../tutorials/ext_gym_environment.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Robotic Python Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lecture Script</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reference-material">Reference material</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coding-getting-started">Coding Getting Started</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scene-robot-description">Scene &amp; Robot Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transformations">Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coordinates-and-composition-of-transformations">Coordinates and Composition of Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scene-tree-or-forest">Scene Tree or Forest</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kinematics">Kinematics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#robots-as-parameterized-trees">Robots as Parameterized Trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#forward-kinematics">Forward Kinematics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jacobians">Jacobians</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rotational-joint">Rotational Joint</a></li>
<li class="toctree-l4"><a class="reference internal" href="#translational-joint">Translational Joint</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quaternion-joint">Quaternion Joint</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#general-concept-of-differentiable-features">General Concept of Differentiable Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary-implementing-a-kinematic-engine">Summary: Implementing a Kinematic Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inverse-kinematics">Inverse Kinematics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-an-nlp-from-features">Building an NLP from features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#classical-derivation-of-pseudo-inverse-jacobian-solution">Classical Derivation of Pseudo-Inverse Jacobian Solution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#d-transformations-rotations-quaternions">3D Transformations, Rotations, Quaternions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rotations">Rotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sectransformations">Transformations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#a-note-on-forward-vs-backward-of-frame-and-coordinate-transforms">A note on “forward” vs. “backward” of frame and coordinate transforms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#splines">Splines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#single-cubic-spline-for-timing-optimal-control-to-a-target">Single cubic spline for timing-optimal control to a target</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#single-piece-optimal-timing-control">Single-piece optimal timing control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hermite-cubic-splines">Hermite Cubic Splines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-splines">B-Splines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#b-spline-matrix-for-time-discretized-paths">B-spline Matrix for Time Discretized Paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ensuring-b-splines-pass-through-waypoints">Ensuring B-splines pass through waypoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ensuring-boundary-velocities">Ensuring boundary velocities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gradients">Gradients</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#code-references">Code References</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nlp-interface">NLP interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#yaml-graph-files">Yaml-Graph Files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cameras">Cameras</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#image-camera-world-coordinates">Image, Camera, &amp; World Coordinates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#homogeneous-coordinates-camera-matrix-p">Homogeneous coordinates &amp; Camera Matrix <span class="math notranslate nohighlight">\(P\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="#calibration-as-estimating-p-k-r-t-from-depth-data">Calibration as Estimating <span class="math notranslate nohighlight">\(P,K,R,t\)</span> from Depth Data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">robotic python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Robotic Python Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Lecture Script</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/script/script.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="lecture-script">
<h1>Lecture Script<a class="headerlink" href="#lecture-script" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<section id="reference-material">
<h3>Reference material<a class="headerlink" href="#reference-material" title="Link to this heading"></a></h3>
<p>In terms of background, please refer to the Maths for Intelligent
Systems
&lt;<a class="reference external" href="https://www.user.tu-berlin.de/mtoussai/teaching/Lecture-Maths.pdf">https://www.user.tu-berlin.de/mtoussai/teaching/Lecture-Maths.pdf</a>&gt; as
well as the Intro to Robotics
&lt;<a class="reference external" href="https://www.user.tu-berlin.de/mtoussai/teaching/Lecture-Robotics.pdf">https://www.user.tu-berlin.de/mtoussai/teaching/Lecture-Robotics.pdf</a>&gt;
lecture scripts. Here a list of further teaching material:</p>
<ul>
<li><p>Craig, J.J.: <em>Introduction to robotics: mechanics and control</em>.
Addison-Wesley New York, 1989. (3rd edition 2006)</p></li>
<li><p>Steven M. LaValle: <em>Planning Algorithms</em>. Cambridge University Press,
2006.</p>
<p><strong>online:</strong> <a class="reference external" href="http://planning.cs.uiuc.edu/">http://planning.cs.uiuc.edu/</a></p>
</li>
<li><p>VideoLecture by Oussama Khatib:
&lt;<a class="reference external" href="http://videolectures.net/oussama_khatib/">http://videolectures.net/oussama_khatib/</a>&gt;</p>
<p>(focus on kinematics, dynamics, control)</p>
</li>
<li><p>Oliver Brock’s lecture
&lt;<a class="reference external" href="http://www.robotics.tu-berlin.de/menue/teaching/">http://www.robotics.tu-berlin.de/menue/teaching/</a>&gt;</p></li>
<li><p>Stefan Schaal’s lecture Introduction to Robotics:
&lt;<a class="reference external" href="http://www-clmc.usc.edu/Teaching/TeachingIntroductionToRoboticsSyllabus">http://www-clmc.usc.edu/Teaching/TeachingIntroductionToRoboticsSyllabus</a>&gt;</p>
<p>(focus on control, useful: Basic Linear Control Theory (analytic
solution to simple dynamic model <span class="math notranslate nohighlight">\(\to\)</span> PID), chapter on
dynamics)</p>
</li>
<li><p>Chris Atkeson’s “Kinematics, Dynamic Systems, and Control”
&lt;<a class="reference external" href="http://www.cs.cmu.edu/">http://www.cs.cmu.edu/</a> cga/kdc/&gt;</p>
<p>(uses Schaal’s slides and LaValle’s book, useful: slides on 3d
kinematics &lt;<a class="reference external" href="http://www.cs.cmu.edu/">http://www.cs.cmu.edu/</a> cga/kdc-10/ewhitman1.pptx&gt;)</p>
</li>
<li><p>CMU lecture “introduction to robotics”
&lt;<a class="reference external" href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/16311/www/current/">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/16311/www/current/</a>&gt;</p>
<p>(useful: PID control, simple BUGs algorithms for motion planning,
non-holonomic constraints)</p>
</li>
<li><p><em>Springer Handbook of Robotics, Bruno Siciliano, Oussama Khatib</em>
&lt;<a class="reference external" href="http://link.springer.com/book/10.1007/978-3-319-32552-1">http://link.springer.com/book/10.1007/978-3-319-32552-1</a>&gt;</p></li>
<li><p>LaValle’s <em>Planning Algorithms</em> &lt;<a class="reference external" href="http://planning.cs.uiuc.edu/">http://planning.cs.uiuc.edu/</a>&gt;</p></li>
</ul>
</section>
<section id="coding-getting-started">
<h3>Coding Getting Started<a class="headerlink" href="#coding-getting-started" title="Link to this heading"></a></h3>
<p>Please follow the instructions at github/robotics-course
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotics-course/">https://marctoussaint.github.io/robotics-course/</a>&gt; for setting up the
python package. This includes a series of tutorials, which can also be
downloaded here &lt;<a class="reference external" href="https://github.com/MarcToussaint/rai-tutorials">https://github.com/MarcToussaint/rai-tutorials</a>&gt;.</p>
</section>
</section>
<section id="scene-robot-description">
<h2>Scene &amp; Robot Description<a class="headerlink" href="#scene-robot-description" title="Link to this heading"></a></h2>
<p>Generally speaking, a scene is a collection of objects (including robot
parts). We typically assume objects to be rigid bodies with fixed shape
– which clearly is a simplification relative to real world. More about
this below, in section 1.16.1.</p>
<p>However, formally we define a scene as a collection of <strong>frames</strong>, which
is short for coordinate frames. We can think of these frames as oriented
locations in 3D space – and various things can be associated to these
frames. If a rigid shape and mass is associated to a frame, then it
makes a typical rigid body. But frames can also be associated to robot
joint locations or virtual landmarks.</p>
<section id="transformations">
<h3>Transformations<a class="headerlink" href="#transformations" title="Link to this heading"></a></h3>
<p>Let <span class="math notranslate nohighlight">\(i=1,..,m\)</span> enumerate <span class="math notranslate nohighlight">\(m\)</span> frames in a scene. Each frame
has a <strong>pose</strong> <span class="math notranslate nohighlight">\(X_i\in SE(3)\)</span>, where
<span class="math notranslate nohighlight">\(SE(3) = {\mathbb{R}}^3 \times SO(3)\)</span> is the group of 3D
transformations, namely the cross-product of translations and rotations.
We always assume a world origin to be defined and use the word <em>pose</em>
specifically for the transformation from world origin to the object
frame.</p>
<p>Transformations in <span class="math notranslate nohighlight">\(A\in SE(3)\)</span> are tuples <span class="math notranslate nohighlight">\(A = (t, r)\)</span>,
where <span class="math notranslate nohighlight">\(t\in{\mathbb{R}}^3\)</span> is a translation and <span class="math notranslate nohighlight">\(r\in SO(3)\)</span>
a rotation – see Appendix 1.12 for more details.
Rotations can be represented as matrix <span class="math notranslate nohighlight">\(R\)</span> (see the Maths script
on properties of rotation matrices), and a pose as the <span class="math notranslate nohighlight">\(4\times 4\)</span>
homogeneous transform
<span class="math notranslate nohighlight">\(\left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right)\)</span>.
However, more commonly in code we represent rotations as a 4D quaternion
<span class="math notranslate nohighlight">\(r\in{\mathbb{R}}^4\)</span> with unit length <span class="math notranslate nohighlight">\(|r| = 1\)</span>. I always
use the convention <span class="math notranslate nohighlight">\(r=(r_0,\bar r)\)</span>, where the first entry
<span class="math notranslate nohighlight">\(r_0 = \cos(\theta/2)\)</span> relates to the total rotation angle
<span class="math notranslate nohighlight">\(\theta\)</span>, and the last three entries
<span class="math notranslate nohighlight">\(\bar r = \sin(\theta/2)~ \underline w\)</span> relate to the unit length
rotation axis <span class="math notranslate nohighlight">\(\underline w\)</span>.</p>
<p>Euler angles and the scaled rotation vector are alternative rotation
representations – but never use them. The appendix
1.12 introduces to all these representations and
derives conversion equations to relate them.</p>
<p>The 1st tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html">https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html</a>&gt;
illustrates how you can manually define frames in a configuration and
set absolute or relative transformations.</p>
</section>
<section id="coordinates-and-composition-of-transformations">
<h3>Coordinates and Composition of Transformations<a class="headerlink" href="#coordinates-and-composition-of-transformations" title="Link to this heading"></a></h3>
<p><a href="#id4"><span class="problematic" id="id5">|image|</span></a></p>
<p>[figTransforms] Composition of transforms.</p>
<p>Consider Fig. [figTransforms], were we have three
frames <span class="math notranslate nohighlight">\(1,2,3\)</span> in addition to the world origin frame <span class="math notranslate nohighlight">\(W\)</span>.
Each frame has a global pose <span class="math notranslate nohighlight">\(X_1, X_2, X_3\)</span>, and relative
transforms <span class="math notranslate nohighlight">\(Q_{W\to 1}, Q_{1\to 2}, Q_{2\to 3}\)</span>. We have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
X_1 &amp;= Q_{W\to 1} \\
X_2 &amp;= Q_{W\to 1} \circ Q_{1\to2} \\
X_3 &amp;= Q_{W\to 1} \circ Q_{1\to2} \circ Q_{2\to3} ~.\end{aligned}\end{split}\]</div>
<p>Note that when composing relative transforms, we concatenate (append)
them <em>on the right</em>! Intuitively, this describes a concatenation of
turtle commands, where a turtle is initially placed on the world origin,
then translates, then rotations, then translates <em>relative to its own
pose</em>, then rotations <em>relative to its own pose</em>, etc, and ends up in
pose <span class="math notranslate nohighlight">\(X_3\)</span>.</p>
<p>Now consider the position of a point in 3D space. It can be given in
world coordinates <span class="math notranslate nohighlight">\(x^W\)</span>, but also in relative coordinates
<span class="math notranslate nohighlight">\(x^1, x^2, x^3\)</span>. We have</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
x^W &amp;= Q_{W\to 1}~ Q_{1\to2}~ Q_{2\to3}~ x^3 = X_3~ x^3 ~.\end{aligned}\]</div>
<p>Now you might want to ask: “does <span class="math notranslate nohighlight">\(Q_{1\to 2}\)</span> describe the forward
or the backward transformation from frame <span class="math notranslate nohighlight">\(1\)</span> to frame <span class="math notranslate nohighlight">\(2\)</span>?”
But this question is somewhat ill-posed. The situation is:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q_{1\to 2}\)</span> describes the translation and rotation of <em>frame</em>
<span class="math notranslate nohighlight">\(2\)</span> <em>relative</em> to <span class="math notranslate nohighlight">\(1\)</span>. So you may call it the “forward
FRAME transformation”.</p></li>
<li><p><span class="math notranslate nohighlight">\(Q_{1\to 2}\)</span> describes the coordinate transformation from
<span class="math notranslate nohighlight">\(x^2\)</span> to <span class="math notranslate nohighlight">\(x^1 = Q_{1\to 2} x^2\)</span>. So you may call it the
“backward COORDINATE transformation”.</p></li>
</ul>
<p>In the view of fundamental linear algebra, this should not surprise as
basis vectors transform <em>covariant</em>, while coordinates transform
<em>contra-variant</em>. The appendix 1.12.2.1 explains
this again in more detail and with an explicit example.</p>
</section>
<section id="scene-tree-or-forest">
<h3>Scene Tree or Forest<a class="headerlink" href="#scene-tree-or-forest" title="Link to this heading"></a></h3>
<p>Scenes are typically represented as trees, with the world origin as a
root, and the pose of children specified by a <em>relative</em> transformation
from the parent. For instance, a scene with a book on a table on the
ground on the world, would have four frames with poses
<span class="math notranslate nohighlight">\(X_0, X_1, X_2, X_3\)</span> (of the world, ground, table, book), but the
scene would typically be represented by relative transforms
<span class="math notranslate nohighlight">\(Q_1, Q_2, Q_3\)</span> such that</p>
<div class="math notranslate nohighlight">
\[X_i = X_{i{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}} \circ Q_i ~.\]</div>
<p>Note that every frame can only have a single parent, and we can
abbreviate the notation <span class="math notranslate nohighlight">\(Q_i \equiv Q_{\text{parent}(i)\to i}\)</span>.</p>
<p>Scenes can also be a forest of frames, where some frames have no parent
and their pose <span class="math notranslate nohighlight">\(X_i\)</span> must be specified, while for non-roots the
relative transform <span class="math notranslate nohighlight">\(Q_i\)</span> is specified. We usually only talk about
trees, but include meaning forests.</p>
<p>The 1st tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html">https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html</a>&gt;
also demonstrates how to define a frame a <em>child</em> of another, thereby
defining a frame tree. Instead of the absolute pose <code class="docutils literal notranslate"><span class="pre">X</span></code>, you typically
specify the relative transformation <code class="docutils literal notranslate"><span class="pre">Q</span></code> for such a child frame.</p>
</section>
</section>
<section id="kinematics">
<h2>Kinematics<a class="headerlink" href="#kinematics" title="Link to this heading"></a></h2>
<section id="robots-as-parameterized-trees">
<h3>Robots as Parameterized Trees<a class="headerlink" href="#robots-as-parameterized-trees" title="Link to this heading"></a></h3>
<p>The key thing in robotics is that some relative transforms (between
robot links) are “motorized” and can be moved. Formally, this means that
<em>some</em> of the relative transforms <span class="math notranslate nohighlight">\(Q_i\)</span> in our scene have
<strong>degrees of freedom</strong> (dof) <span class="math notranslate nohighlight">\(q_i \in {\mathbb{R}}^{d_i}\)</span>.</p>
<p>For typical robots (with hinge or linear joints) each <span class="math notranslate nohighlight">\(q_i\)</span> is
just a single number (the joint dimensionality <span class="math notranslate nohighlight">\(d_i=1\)</span>). E.g., a
<strong>hinge</strong> joint around the (local) <span class="math notranslate nohighlight">\(x\)</span>-axis has a single dof
<span class="math notranslate nohighlight">\(q_i\in{\mathbb{R}}\)</span> that parameterizes the relative transform</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
Q_i(q_i) =  \left(\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos(q_i) &amp; -\sin(q_i) &amp; 0 \\
0 &amp;  \sin(q_i) &amp; \cos(q_i) &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>And a <strong>prismatic</strong> (or translational) joint along the (local)
<span class="math notranslate nohighlight">\(x\)</span>-axis parameterizes</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
Q_i(q_i) =  \left(\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; q \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Other joint types (universal, cylindrical) are less common.</p>
<p>A bit special are <strong>ball (spherical) joints</strong>: They parameterize
arbitrary rotations within <span class="math notranslate nohighlight">\(Q_i\)</span> – in principle they could be
described as having 3 dofs (as the Lie group <span class="math notranslate nohighlight">\(SO(3)\)</span> is a 3D
manifold), however, in code it is practice to again use quaternions to
parameterize rotations, which means <span class="math notranslate nohighlight">\(q_i\in{\mathbb{R}}^4\)</span> for
ball joints. However, note that this is an over parameterization: If
<span class="math notranslate nohighlight">\(q_i\)</span> is externally “set” by a user or some algorithm, it may not
(exactly) be normalized but <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span> is defined to be the proper
rotation that corresponds to the quaternion <span class="math notranslate nohighlight">\(q_i/|q_i|\)</span>. Note that
if a user or algorithms sets such a quaternion parameter to zero, that’s
a singularity and strict error.</p>
<p>In the 1st tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html">https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html</a>&gt;,
when a joint is defined for the first time, play around with alternative
joint types, e.g. a <code class="docutils literal notranslate"><span class="pre">quatBall</span></code>. The tutorial also lists which joint
types are pre-defined.</p>
<p>In the scene tree, some of the relative transforms <span class="math notranslate nohighlight">\(Q_i\)</span> are
parameterized by dofs, <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span>. Note that
<span class="math notranslate nohighlight">\(X_\text{parent$(i)$}\)</span> is the <strong>joint origin</strong>, i.e., determines
the location and orientation of the joint axis, while
<span class="math notranslate nohighlight">\(X_i = X_\text{parent$(i)$} Q_i\)</span> is the <strong>joint (output) frame</strong>.
In a robot structure one typically has chains of alternating rigid and
parameterized transforms, e.g.,</p>
<p>a rigid transform <span class="math notranslate nohighlight">\(Q_{\pi(i)}\)</span> from world into the origin of joint
<span class="math notranslate nohighlight">\(i\)</span></p>
<p>a parameterized transform <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span> representing the joint motion
(We call this one the <em>joint frame</em>, as it hosts the joint dofs.)</p>
<p>a rigid transform <span class="math notranslate nohighlight">\(Q_{i \to \pi(j)}\)</span> from the output of <span class="math notranslate nohighlight">\(i\)</span>
into the origin of a following joint <span class="math notranslate nohighlight">\(j\)</span></p>
<p>a parameterized transform <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span></p>
<p>etc</p>
<p>There is a minimalistic convention of describing robot structures,
called Denavit-Hartenberg convention. These describe the rigid
transformations between joints using only 4 numbers instead of 6 (which
pre-determines the zero calibration as well as the “lateral” positioning
of the following joint origin). But there is no need to use this
convention and the above notation is conceptually cleaner and leads to
intuitive, freely user-defined joint origins.</p>
<p>In the tutorial on configuration editing
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_3_import_edit.html">https://marctoussaint.github.io/robotic/tutorials/config_3_import_edit.html</a>&gt;
you find a section on interactively editing a scene description file
<code class="docutils literal notranslate"><span class="pre">mini.g</span></code>. Using this you can try to invent your own robot and
environment. The tutorial also shows how to load pre-defined robot
models. The appendix [secConfigFiles] provides a
more formal specification of the yaml-style file syntax.</p>
</section>
<section id="forward-kinematics">
<h3>Forward Kinematics<a class="headerlink" href="#forward-kinematics" title="Link to this heading"></a></h3>
<p>We use the word <strong>configuration</strong> for an “articulated scene”, i.e.,
where some relative transforms <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span> are parameterized by
dofs <span class="math notranslate nohighlight">\(q_i \in {\mathbb{R}}^{d_i}\)</span> (and also other dofs such as
forces or timings might be represented). A configuration can include
multiple robots – from our perspective there is no difference between
one or multiple robots. It’s just a parameterized forest of frames.</p>
<p>We define the <strong>joint vector</strong> <span class="math notranslate nohighlight">\(q\in{\mathbb{R}}^n\)</span> to be the
stacking of all dofs <span class="math notranslate nohighlight">\(q_i\)</span> (all dofs of a configuration). Given
the joint vector, we can forward chain all relative transformations in
the scene and thereby compute the absolute pose <span class="math notranslate nohighlight">\(X_i(q)\)</span> of every
frame as a function of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>This function <span class="math notranslate nohighlight">\(q \mapsto X_i(q)\)</span> is the core of <strong>forward
kinematics</strong>. It describes how the joint vector <span class="math notranslate nohighlight">\(q\)</span> determines the
pose of all frames in the configuration.</p>
<p>The precise definition of the term <strong>forward kinematics</strong> varies across
textbooks. I find the most concise definition to be the mapping from all
dofs <span class="math notranslate nohighlight">\(q\)</span> to the full configuration state
<span class="math notranslate nohighlight">\(\{X_i(q)\}_{i=1}^m\)</span>, which so far we described in terms of all
frame poses. This definition is consistent with the formal description
of <em>kinematics</em> as the theory of possible motions of a system
configuration (see 1.16.2).</p>
<p>But in practice, the word forward kinematics is often used simply as the
mapping from <span class="math notranslate nohighlight">\(q\)</span> to one particular “feature” of the configuration.
For instance, if <span class="math notranslate nohighlight">\(X_i(q)=(t_i(q),r_i(q))\)</span> is the pose of some
frame <span class="math notranslate nohighlight">\(i\)</span> (e.g. the “end-effector”), forward kinematics can
describe the mapping</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(q\mapsto t_i(q)\)</span>   to the position of frame <span class="math notranslate nohighlight">\(i\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(q\mapsto r_i(q) \cdot \textbf{e}_x\)</span>   to the <span class="math notranslate nohighlight">\(x\)</span>-axis of
frame <span class="math notranslate nohighlight">\(i\)</span> (where <span class="math notranslate nohighlight">\(\textbf{e}_x = (1,0,0)^{\!\top\!}\)</span>).</p></li>
<li><p><span class="math notranslate nohighlight">\(q\mapsto X_i(q) p\)</span>   to the world coordinate of a point
attached to frame <span class="math notranslate nohighlight">\(i\)</span> with fixed relative offset <span class="math notranslate nohighlight">\(p\)</span>.</p></li>
</ul>
<p>Each of these are 3-dimensional features. Let introduce a more formal
notation for these three basic features:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
q \mapsto \phi^{\textsf{pos}}_{i,p}(q) &amp;= X_i(q)~ p \quad\in {\mathbb{R}}^3 ~, \\
q \mapsto \phi^{\textsf{vec}}_{i,v}(q) &amp;= r_i(q) \cdot v \quad\in {\mathbb{R}}^3 ~, \\
q \mapsto \phi^{\textsf{quat}}_{i}(q) &amp;= r_i(q) \quad\in {\mathbb{R}}^4 ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi^{\textsf{pos}}_{i,p}(q)\)</span> is the (world) position of a
point attached to frame <span class="math notranslate nohighlight">\(i\)</span> with relative offset <span class="math notranslate nohighlight">\(p\)</span>,
<span class="math notranslate nohighlight">\(\phi^{\textsf{vec}}_{i,v}(q)\)</span> is the world coordinates of a
vector <span class="math notranslate nohighlight">\(v\)</span> attached to frame <span class="math notranslate nohighlight">\(i\)</span>, and
<span class="math notranslate nohighlight">\(\phi^{\textsf{quat}}_{i}(q)\)</span> is the 4D quaternion orientation of
frame <span class="math notranslate nohighlight">\(i\)</span>. From these three, many others features can be derived.</p>
<p>E.g., also the <span class="math notranslate nohighlight">\(3\times 3\)</span> rotation matrix is a useful basic
feature (as it is often used in equations). We can easily construct it
by concatenating columns, <span class="math notranslate nohighlight">\(\phi^{\textsf{rot}}_i =
(\phi^{\textsf{vec}}_{i,e_x}, \phi^{\textsf{vec}}_{i,e_y}, \phi^{\textsf{vec}}_{i,e_z}) \in {\mathbb{R}}^{3\times
3}\)</span> for basis vectors <span class="math notranslate nohighlight">\(e_x,e_y,e_z\)</span> of frame <span class="math notranslate nohighlight">\(i\)</span>. (Note that
the Jacobian (defined later) of this is a <span class="math notranslate nohighlight">\(3\times 3 \times n\)</span>
tensor.)</p>
<p>The output space of the kinematic map is also called <strong>task space</strong>.
However, I often just call it <strong>kinematic feature</strong>.</p>
<p>The 1st tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html">https://marctoussaint.github.io/robotic/tutorials/config_1_intro.html</a>&gt;
illustrates how you get the joint vector <span class="math notranslate nohighlight">\(q\)</span> and set it. This way
you can animate the configuration. Also the positions and orientations
of all frames can be queried directly – realizing the most basic kind of
forward kinematics.</p>
</section>
<section id="jacobians">
<h3>Jacobians<a class="headerlink" href="#jacobians" title="Link to this heading"></a></h3>
<p>We will use kinematic features <span class="math notranslate nohighlight">\(\phi\)</span> to formulate differentiable
constraint and optimization problem. Therefore, we assume all kinematic
features <span class="math notranslate nohighlight">\(\phi\)</span> are differentiable and we can efficiently compute
the <strong>Jacobian</strong></p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
J(q) = \frac{\partial}{\partial q}\phi(q) ~.\end{aligned}\]</div>
<p>If <span class="math notranslate nohighlight">\(y = \phi(q)\)</span>, then this Jacobian tells us how a velocity
<span class="math notranslate nohighlight">\(\dot q\)</span> in joint space implies a velocity <span class="math notranslate nohighlight">\(\dot y\)</span> in task
space,</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\dot y = J(q) \dot q ~.\end{aligned}\]</div>
<p>Recall that the forward kinematics is essentially implemented by forward
chaining the relative transforms <span class="math notranslate nohighlight">\(Q_i\)</span>. If we use an
auto-differentiable programming language for this, we’d directly have
the Jacobians. However, the Jacobians can also directly be expressed
analytically and their computation turns out simpler and more efficient
than the forward chaining itself. To implement a kinematic engine we
essentially need to figure out how the different joint types contribute
to the Jacobians of the three basic features above. This is covered by
considering the following cases:</p>
<section id="rotational-joint">
<h4>Rotational Joint<a class="headerlink" href="#rotational-joint" title="Link to this heading"></a></h4>
<p>Consider that somewhere on the path from world to frame <span class="math notranslate nohighlight">\(i\)</span> there
is a rotational (hinge) joint <span class="math notranslate nohighlight">\(j\)</span> positioned at <span class="math notranslate nohighlight">\(p_j\)</span> and
with unit axis vector <span class="math notranslate nohighlight">\(a_j\)</span> (both in world coordinates). Now
consider a point attached to frame <span class="math notranslate nohighlight">\(i\)</span> at world coordinate
<span class="math notranslate nohighlight">\(p\)</span>. (Note that we needed forward kinematics to determine
<span class="math notranslate nohighlight">\(p_j, a_j\)</span>, and <span class="math notranslate nohighlight">\(p\)</span>.) Then the velocity <span class="math notranslate nohighlight">\(\dot p\)</span>
relates to the joint angle velocity <span class="math notranslate nohighlight">\(\dot q_j\)</span> by</p>
<div class="math notranslate nohighlight">
\[\dot p = [a_j \times (p - p_j)]~ \dot q_j ~.\]</div>
<p>Now assume a vector <span class="math notranslate nohighlight">\(v\)</span> attached to frame <span class="math notranslate nohighlight">\(i\)</span>. Its velocity
is</p>
<div class="math notranslate nohighlight">
\[\dot v = [a_j \times v]~ \dot q_j = [-{\text{skew}}(v)~ a_j]~ \dot q_j ~.\]</div>
<p>Now consider the quaternion <span class="math notranslate nohighlight">\(r_i\)</span> of frame <span class="math notranslate nohighlight">\(i\)</span>. Its velocity
(much less obvious, see appendix Eq. ([eqQuatVel]))
is</p>
<div class="math notranslate nohighlight">
\[\dot r_i = {\frac{1}{2}}[(0,a_j)\circ r_i]~ \dot q_j ~.\]</div>
<p>Recall that <span class="math notranslate nohighlight">\(q\in{\mathbb{R}}^n\)</span> is the full joint vector. Let
<span class="math notranslate nohighlight">\(j\)</span> be the dof index of our rotational joint such that
<span class="math notranslate nohighlight">\(q_j \in {\mathbb{R}}\)</span> is the scalar joint angle. Further, let
<span class="math notranslate nohighlight">\(p_j,a_j\)</span> be the joint position and axis, and <span class="math notranslate nohighlight">\(p\)</span> a world
query point. We define two matrices that are zero except for the
provided columns:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
J^{\textsf{ang}}\in {\mathbb{R}}^{3 \times n} \quad\text{with}\quad &amp;J^{\textsf{ang}}_{:,j} = a_j ~, \\
J^{\textsf{pos}}(p) \in {\mathbb{R}}^{3 \times n} \quad\text{with}\quad &amp;J^{\textsf{pos}}_{:,j} = a_j \times (p - p_j) ~.\end{aligned}\end{split}\]</div>
<p>With these two matrices we can rewrite the above equations as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\dot p &amp;= J^{\textsf{pos}}(p)~ \dot q \\
\dot v &amp;= [-{\text{skew}}(v)~ J^{\textsf{ang}}(p)]~ \dot q \\
\dot r &amp;= {\frac{1}{2}}[\text{Skew}(r)~ \bar J^{\textsf{ang}}(p)]~ \dot q \quad\text{where}\quad \text{Skew}(w,x,y,z) =
 \left(\begin{array}{cccc}
   +w &amp; -x &amp; -y &amp; -z \\
   +x &amp; +w &amp; +z &amp; -y \\
   +y &amp; -z &amp; +w &amp; +x \\
   +z &amp; +y &amp; -x &amp; +w\end{array}\right)  ~, \label{eqQuatRate}\end{aligned}\end{split}\]</div>
<p>where by convention the cross-product <span class="math notranslate nohighlight">\([A\times v]\)</span> for a
<span class="math notranslate nohighlight">\(3\times n\)</span> matrix with a 3-vector takes the cross-products
<em>row-wise</em> (could perhaps better be written <span class="math notranslate nohighlight">\([-v\times A]\)</span>). The
last equation is derived in the appendix with
Eq. ([eqQuatVel]), where we discuss how an angular
velocity translates to a quaternion velocity. The bar in
<span class="math notranslate nohighlight">\(\bar J^{\textsf{ang}}\)</span> makes this a <span class="math notranslate nohighlight">\(4\times n\)</span> matrix by
inserting a zero top row (analogous to <span class="math notranslate nohighlight">\((0,w)\)</span> in
([eqQuatVel])). The <span class="math notranslate nohighlight">\(\text{Skew}\)</span> is an unusual
definition of a skew matrix for quaternions, so that quaternion
multiplication <span class="math notranslate nohighlight">\(a \circ b\)</span> can be written linearly as
<span class="math notranslate nohighlight">\(\text{Skew}(b)~ a\)</span>.</p>
<p>Now, if in our scene tree we have more than one rotational joint between
world and frame <span class="math notranslate nohighlight">\(i\)</span>, each of these joints simply contribute
non-zero columns to our basic matrices
<span class="math notranslate nohighlight">\(J^{\textsf{ang}}, J^{\textsf{pos}}(p)\)</span>. So this is the core of
what we have to implement for rotational joints.</p>
</section>
<section id="translational-joint">
<h4>Translational Joint<a class="headerlink" href="#translational-joint" title="Link to this heading"></a></h4>
<p>A translational (prismatic) joint on the path from world to frame
<span class="math notranslate nohighlight">\(i\)</span> also contributes a column to the basic matrix
<span class="math notranslate nohighlight">\(J^{\textsf{pos}}(p)\)</span>, but contributes notion to
<span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span> (as it does not imply rotational velocity in
the sub-branch). Specifically, let <span class="math notranslate nohighlight">\(a_j\)</span> be the translational axis
of the joint with dof index <span class="math notranslate nohighlight">\(j\)</span>, then it simply contributes a
column</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
J^{\textsf{pos}}_{:,j} = a_j ~.\end{aligned}\]</div>
<p>That’s it for translational joints.</p>
</section>
<section id="quaternion-joint">
<h4>Quaternion Joint<a class="headerlink" href="#quaternion-joint" title="Link to this heading"></a></h4>
<p>Trickier, but important for ball and free joints is to also know how a
quaternion joint contributes columns to <span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span> and
<span class="math notranslate nohighlight">\(J^{\textsf{pos}}(p)\)</span>. Modifying a quaternion parameterization
<span class="math notranslate nohighlight">\(q_j\in{\mathbb{R}}^4\)</span> of a relative transform <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span>
implies in some way a rotational velocity down the branch. So the effect
should be similar to a rotational joint, but without fixed axis and
modulated by the normalization of <span class="math notranslate nohighlight">\(q_j\)</span>. The solution is derived
in the appendix with Eq. ([eqQuatJac]) and summarized
here: Let <span class="math notranslate nohighlight">\(X_j\)</span> be the <em>output</em> pose of the quaternion joint.
(Yes, output!) And let <span class="math notranslate nohighlight">\(R_j\)</span> be the <span class="math notranslate nohighlight">\(3\times 3\)</span> rotation
matrix for the world pose <span class="math notranslate nohighlight">\(X_j\)</span>, and let
<span class="math notranslate nohighlight">\(r_j \in {\mathbb{R}}^4\)</span> be the quaternion of the <em>relative</em> joint
transform <span class="math notranslate nohighlight">\(Q_j\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuatJoint1}
J^{\textsf{ang}}_{:,j} = \frac{1}{|q|} R_j J(r_j) ~,\quad\text{where}\quad
J(r)_{:,k} &amp;= -2 (e_k \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})_{1:3} ~.\end{aligned}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(e_i\)</span> for <span class="math notranslate nohighlight">\(k=0,..,3\)</span> are the unit quaternions and the
matrix <span class="math notranslate nohighlight">\(J(r)\in{\mathbb{R}}^{3 \times 4}\)</span> describes how a
variation of a quaternion <span class="math notranslate nohighlight">\(r\)</span> induces a 3D rotation vector
relative to the <em>output</em> space of <span class="math notranslate nohighlight">\(r\)</span>. I call this the quaternion
Jacobian. The derivation is found in the appendix when discussion how a
quaternion velocity implies and angular velocity. The multiplication
with <span class="math notranslate nohighlight">\(R_j\)</span> transforms this rotation vector to world coordinates.
The division by <span class="math notranslate nohighlight">\(|q_j|\)</span> accounts when the dof <span class="math notranslate nohighlight">\(q_j\)</span> is not
(exactly) normalized.</p>
<p>As we figured out the angular vector induced by a variation of a
quaternion joint, this also defines the column it contributes to the
positional Jacobian:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
J^{\textsf{pos}}_{:,j}(p) = [\frac{1}{|q|} R_j J(r_j)] \times (p - p_j) ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(p_j\)</span> is the position of the quaternion joint.</p>
<p>Note how differently we treat the quaternion <span class="math notranslate nohighlight">\(q_j\)</span> as a joint
parameterization <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span> and the quaternion <span class="math notranslate nohighlight">\(r_i\)</span> as a
kinematic (“output”) feature of frame <span class="math notranslate nohighlight">\(i\)</span>. For instance, we can
have the Jacobian of the quaternion <span class="math notranslate nohighlight">\(r_i\)</span> w.r.t. the quaternion
joint parameterization <span class="math notranslate nohighlight">\(q_j\)</span>, by inserting
([eqQuatJoint1]) into
([eqQuatRate]). And even if all other transformation
in the scene are identities and the output quaternion <span class="math notranslate nohighlight">\(r_i\)</span> is
“essentially identical” to the joint quaternion <span class="math notranslate nohighlight">\(q_j\)</span>, the
Jacobian is still not exactly identity, as it accounts for normalization
(and potential flip of sign).</p>
</section>
</section>
<section id="general-concept-of-differentiable-features">
<h3>General Concept of Differentiable Features<a class="headerlink" href="#general-concept-of-differentiable-features" title="Link to this heading"></a></h3>
<p>In the previous sections we focussed on the 3 mappings
<span class="math notranslate nohighlight">\(\phi^{\textsf{pos}}_{i,p}(q), \phi^{\textsf{vec}}_{i,v}(q), \phi^{\textsf{quat}}_{i}(q)\)</span>.
The Jacobians of these are given via <span class="math notranslate nohighlight">\(J^{\textsf{pos}}_{:,j}(p)\)</span>
and <span class="math notranslate nohighlight">\(J^{\textsf{ang}}_{:,j}(p)\)</span>. If these are given
(e.g. implemented by an efficient core kinematics engine), then many
other features can be computed based on them.</p>
<p>We assume a single configuration <span class="math notranslate nohighlight">\(q\)</span>, or a whole set of
configurations <span class="math notranslate nohighlight">\(\{q_1,..,q_T\}\)</span>, with each
<span class="math notranslate nohighlight">\(q_i \in\mathbb{R}\)</span> the DOFs of that configuration.</p>
<p>In general, a (0-order) <strong>feature</strong> <span class="math notranslate nohighlight">\(\phi\)</span> is a differentiable
mapping</p>
<div class="math notranslate nohighlight">
\[\phi: q \mapsto \mathbb{R}^D\]</div>
<p>of a single configuration into some <span class="math notranslate nohighlight">\(D\)</span>-dimensional space.</p>
<p>The features tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_2_features.html">https://marctoussaint.github.io/robotic/tutorials/config_2_features.html</a>&gt;
introduces to features that are readily implemented in the rai code.</p>
<p>(In C++, new features can be implemented by overloading the abstract
Feature class. Implementing new features is typically done by first
evaluating existing features and then “forward chaining” the computation
of the new feature – quite similar to how models are defined in pyTorch
or similar autodiff frameworks. The C++ code uses autodiff (which
<em>forward</em> chains Jacobians directly at computation) for most features.)</p>
<p>When using features in code, one can additionally specify a <code class="docutils literal notranslate"><span class="pre">target</span></code>
and <code class="docutils literal notranslate"><span class="pre">scale</span></code>, which defines a subsequent linear transformation:</p>
<div class="math notranslate nohighlight">
\[\phi(q) \gets \texttt{scale} \cdot (\phi(q) - \texttt{target})\]</div>
<p>Note that the scale can be a matrix, which projects the feature. E.g.,
if you want to define a 2D feature which is the <span class="math notranslate nohighlight">\(xy\)</span>-position of
frame <span class="math notranslate nohighlight">\(i\)</span>, then you can use a matrix
<span class="math notranslate nohighlight">\(\texttt{scale}= \left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0\end{array}\right)\)</span>.</p>
<p>Further, a feature can also be of higher order, which by default means a
finite difference of a zero-order feature. In general, a higher-order
feature is a differentiable mapping</p>
<div class="math notranslate nohighlight">
\[\phi: (q_0,q_1,..,q_k) \mapsto \mathbb{R}^D\]</div>
<p>of a <span class="math notranslate nohighlight">\((k+1)\)</span>-tuple of configurations to a <span class="math notranslate nohighlight">\(D\)</span>-dimensional
space. This is typically used in the context of <strong>path configurations</strong>,
which is a sequence of configurations used in path optimization.</p>
<p>Given any 0-order feature <span class="math notranslate nohighlight">\(\phi\)</span>, by default that defines its 1st
and 2nd order feature as</p>
<div class="math notranslate nohighlight">
\[\phi(q_0,q_1) = \frac{1}{\tau}(\phi(q_1) - \phi(q_0))\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\phi(q_0,q_1,q_2) = \frac{1}{\tau^2}(\phi(q_2) - 2 \phi(q_1) + \phi(q_0)) ~,\]</div>
<p>which are the finite difference approximations of the feature’s velocity
and acceleration. However, one can also directly implement higher-order
features, e.g. to represent dynamics constraints, or more elaborate
acceleration/torque cost features.</p>
</section>
<section id="summary-implementing-a-kinematic-engine">
<h3>Summary: Implementing a Kinematic Engine<a class="headerlink" href="#summary-implementing-a-kinematic-engine" title="Link to this heading"></a></h3>
<p>The above provides all essentials necessary to implement a rather
general kinematic engine. To summarize:</p>
<ul class="simple">
<li><p>Represent a scene configuration as a tree of frames, where for each
frame we store the absolute pose <span class="math notranslate nohighlight">\(X\)</span> and relative transform
<span class="math notranslate nohighlight">\(Q\)</span>. We also annotate which relative transforms <span class="math notranslate nohighlight">\(Q\)</span> have
dofs and how many. We need to maintain an index mapping that tells us
which entries <span class="math notranslate nohighlight">\(q_j\)</span> of the full joint vector parameterize a
given relative transformation <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span> (essentially mapping
between <span class="math notranslate nohighlight">\(q\)</span>-indices and frame indices).</p></li>
<li><p>An efficient implementation of forward chaining transformations:
Given the absolute poses <span class="math notranslate nohighlight">\(X\)</span> of all root frames and all
relative transforms <span class="math notranslate nohighlight">\(Q\)</span>, implement an efficient algorithm to
forward chain transformations to ensure any <span class="math notranslate nohighlight">\(X_i\)</span>. Do this
lazily on demand: Only when an absolute frame <span class="math notranslate nohighlight">\(X_i\)</span> is actually
queried call this forward chaining for this <span class="math notranslate nohighlight">\(X_i\)</span> only.</p></li>
<li><p>An efficient implementation of the matrices <span class="math notranslate nohighlight">\(J^{\textsf{pos}}\)</span>
and <span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span>, which, for any query frame <span class="math notranslate nohighlight">\(i\)</span>,
determines which joints are on the path from <span class="math notranslate nohighlight">\(i\)</span> to a root
frame and for each of these joints contributes the corresponding
columns to <span class="math notranslate nohighlight">\(J^{\textsf{pos}}\)</span> and <span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span>. To
account for large systems (esp. path configurations, see below)
matrices should be returned in sparse format.</p></li>
</ul>
<p>Based on this, one provides more convenient user functions that allow to
query kinematic features for any frame <span class="math notranslate nohighlight">\(i\)</span>, including the pose
<span class="math notranslate nohighlight">\(X_i\)</span>, and on demand also provide the Jacobian of that feature.</p>
</section>
<section id="inverse-kinematics">
<h3>Inverse Kinematics<a class="headerlink" href="#inverse-kinematics" title="Link to this heading"></a></h3>
<p><a href="#id6"><span class="problematic" id="id7">|image|</span></a></p>
<p>We can “puppeteer” a robot by defining optimization problems with task
space constraints and solve for the joint state.</p>
<p>We introduced forward kinematics as a mapping from an
<span class="math notranslate nohighlight">\(n\)</span>-dimensional joint vector <span class="math notranslate nohighlight">\(q\in{\mathbb{R}}^n\)</span> to some
<span class="math notranslate nohighlight">\(d\)</span>-dimensional kinematic feature
<span class="math notranslate nohighlight">\(y=\phi(q) \in{\mathbb{R}}^d\)</span>. Inverse kinematics roughly means to
invert this mapping, i.e., given a desired target <span class="math notranslate nohighlight">\(y^*\)</span> in task
space, find a joint vector <span class="math notranslate nohighlight">\(q\)</span> such that <span class="math notranslate nohighlight">\(\phi(q) = y^*\)</span>. As
often <span class="math notranslate nohighlight">\(n&gt;d\)</span>, the inversion is under-specified (leading to what is
called “redundancy”). But just as the pseudo-inverse of a linear
transformation addresses this, we can generalize this to a non-linear
<span class="math notranslate nohighlight">\(\phi\)</span> – namely in an optimality formulation.</p>
<p>Given <span class="math notranslate nohighlight">\(\phi\)</span> and a target <span class="math notranslate nohighlight">\(y^*\)</span>, a good option is to define
<strong>inverse kinematics</strong> as the non-linear mathematical program (NLP)</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqIKNLP}
q^* = \text{argmin}_q f(q) ~~\text{s.t.}~~\phi(q) = y^* ~.\end{aligned}\]</div>
<p>The cost term <span class="math notranslate nohighlight">\(f(q)\)</span> is called <em>regularization</em> and indicates a
preference among all solutions that satisfy <span class="math notranslate nohighlight">\(\phi(q) = y\)</span>. One
might typically choose it as a squared distance
<span class="math notranslate nohighlight">\(f(q) = |\!|q-q_0|\!|^2_W\)</span> to some “default” <span class="math notranslate nohighlight">\(q_0\)</span>, which
could be the homing state of a robot or its current state.</p>
<p>In practice, I recommend always using a proper NLP solver to solve
inverse kinematics. As discussing optimization is beyond this script we
are here already done with describing inverse kinematics! It is “nothing
more” than defining a constraint problem of the sort
([eqIKNLP]) and passing it to a solver. In the coding
part below I will discuss the richness in options to define such
constraint problems with our differentiable features.</p>
<p>Only for educational purpose we will also derive the classical
pseudo-inverse Jacobian solution to IK below.</p>
<section id="building-an-nlp-from-features">
<h4>Building an NLP from features<a class="headerlink" href="#building-an-nlp-from-features" title="Link to this heading"></a></h4>
<p>Eq. ([eqIKNLP]) describes IK as an NLP. Appendix
1.14.1 provides a technical reference of how we define
NLPs mathematically and in code. Essentially, an NLP is specified by
<em>adding objectives</em>, where each objective is given by a feature function
<span class="math notranslate nohighlight">\(\phi_i\)</span> and an indicator <span class="math notranslate nohighlight">\(\varrho_i\)</span> that defines whether
the feature contributes a linear cost (<code class="docutils literal notranslate"><span class="pre">f</span></code>), sum-of-squares cost
(<code class="docutils literal notranslate"><span class="pre">sos</span></code>), equality constraint (<code class="docutils literal notranslate"><span class="pre">eq</span></code>), or inequality constraint
(<code class="docutils literal notranslate"><span class="pre">ineq</span></code>) to the NLP.</p>
<p>The 1st KOMO tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/komo_1_intro.html">https://marctoussaint.github.io/robotic/tutorials/komo_1_intro.html</a>&gt;
illustrates how an Inverse Kinematics problem can be specified as NLP.
The core is the <code class="docutils literal notranslate"><span class="pre">addObjective</span></code> method, which adds a kinematic feature
(optimally with transformed by scaling and target) as a cost or
constraint (depending on the <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">sos</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, or
<code class="docutils literal notranslate"><span class="pre">ineq</span></code>indicator) to the NLP.</p>
</section>
<section id="classical-derivation-of-pseudo-inverse-jacobian-solution">
<h4>Classical Derivation of Pseudo-Inverse Jacobian Solution<a class="headerlink" href="#classical-derivation-of-pseudo-inverse-jacobian-solution" title="Link to this heading"></a></h4>
<p>I strongly recommend using an NLP solver and general constraint and cost
formulations to tackle IK problems – and you can skip over this section.
However, for completeness I provide here also the basic derivation of
classical pseudo-inverse Jacobian solutions.</p>
<section id="pseudo-inverse-jacobian">
<h5>Pseudo-inverse Jacobian.<a class="headerlink" href="#pseudo-inverse-jacobian" title="Link to this heading"></a></h5>
<p>We first simplify the problem to minimize</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqSoft}
f(q) = |\!|\phi(q) - y^*|\!|^2_C + |\!|q-q_0|\!|^2_W ~.\end{aligned}\]</div>
<p>Instead of exactly ensuring <span class="math notranslate nohighlight">\(\phi(q) = y^*\)</span>, this only minimizes a
penalty <span class="math notranslate nohighlight">\(|\!|\phi(q) - y^*|\!|^2_C\)</span>. Here <span class="math notranslate nohighlight">\(C\)</span> is the norm’s
metric, i.e., <span class="math notranslate nohighlight">\(|\!|v|\!|^2_C = v^{\!\top\!}C v\)</span>, but you may
instead simply assume <span class="math notranslate nohighlight">\(C\)</span> is a scalar. For finite <span class="math notranslate nohighlight">\(C\)</span> and
<span class="math notranslate nohighlight">\(W\)</span> this approximate formulation might be undesirable. But later
we will actually be able to investigate the limit <span class="math notranslate nohighlight">\(C\to\infty\)</span>.</p>
<p>Since this problem is a least squares problem, the canonical approach is
Gauss-Newton. The gradient, approximate Hessian, and Gauss-Newton step
are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial}{\partial q} f(q)
&amp;= 2 (\phi(q)-y^*)^{\!\top\!}C J + 2 (q-q_0)^{\!\top\!}W = {\nabla_{\!\!f}}(q)^{\!\top\!}\\
{\nabla_{\!\!f}^2}(q)
&amp;\approx 2 (J^{\!\top\!}C J + W) \\
\delta(q)
&amp;= - [{\nabla_{\!\!f}^2}(q)]^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} {\nabla_{\!\!f}}(q) = - (J^{\!\top\!}C J + W)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} [J^{\!\top\!}C (\phi(q)-y^*) + W (q-q_0) ]\end{aligned}\end{split}\]</div>
<p>With some identities, this can be rewritten as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\delta(q)
&amp;= J^\sharp (y^* - \phi(q)) + (I - J^\sharp J)~ (q_0 - q) \label{eqIK} \\
J^\sharp
&amp;= (J^{\!\top\!}C J + W)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}C = W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}(J W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}+ C^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
 \text{(Woodbury identity)}\end{aligned}\end{split}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(J^\sharp\)</span> is also called (regularized) pseudo-inverse
of <span class="math notranslate nohighlight">\(J\)</span>. In its second form (RHS of Woodbury), we can take the hard
limit <span class="math notranslate nohighlight">\(C\to\infty\)</span>, where
<span class="math notranslate nohighlight">\(J^\sharp \to W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}(J W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>
or, for <span class="math notranslate nohighlight">\(W={\rm\bf I}\)</span>,
<span class="math notranslate nohighlight">\(J^\sharp \to J^{\!\top\!}(J J^{\!\top\!})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>.</p>
<p>Eq. ([eqIK]) says that, to jump to the (approx.)
Gauss-Newton optimum, we should make a step <span class="math notranslate nohighlight">\(\delta\)</span> in joint
space proportional to the error <span class="math notranslate nohighlight">\((y^*-\phi(q))\)</span> in task space, and
(optionally) combined with a homing step towards <span class="math notranslate nohighlight">\(q_0\)</span> projected
to the task null space via the projection <span class="math notranslate nohighlight">\((I - J^\sharp J)\)</span>.</p>
<p>Performing a single step <span class="math notranslate nohighlight">\(\delta\)</span> is approximate due to the
non-linearity of <span class="math notranslate nohighlight">\(\phi\)</span>. To solve inverse kinematics exactly we
have to iterate Gauss-Newton steps. If lucky, we can use full stepsizes
(<span class="math notranslate nohighlight">\(\alpha= 1\)</span> in the speak of line search) and iterate
<span class="math notranslate nohighlight">\(q_{k{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}} \gets q_k + \delta(q_k)\)</span>
until convergence, and will have an exact IK solution. If <span class="math notranslate nohighlight">\(\phi\)</span>
is very non-linear, we may have to do line searches along the step
directions to ensure convergence. If <span class="math notranslate nohighlight">\(\phi\)</span> is non-convex, we may
converge to a local optimum that depends on the initialization.</p>
</section>
<section id="on-the-fly-ik">
<h5>On the fly IK.<a class="headerlink" href="#on-the-fly-ik" title="Link to this heading"></a></h5>
<p>Inverse kinematics is sometimes being used to generate robot motion on
the fly. In a sense, rather than letting an optimization algorithm find
an IK solution and then start moving the robot to it (we we’ll do it
below), you let the robot directly move (generate a smooth path) towards
an IK solution. This is heuristic, and I eventually don’t recommend it.
But it’s standard practice, so let’s mention it:</p>
<p>Let the robot be in state <span class="math notranslate nohighlight">\(q\)</span>, and we have a task space target
<span class="math notranslate nohighlight">\(y^*\)</span>. We may compute a desired robot motion</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\dot q = \alpha\Big[ J^\sharp (y^* - \phi(q)) + (I - J^\sharp J) (q_0 - q) \Big] ~.\end{aligned}\]</div>
<p>In a sense, this mimics performing (integrating over time) infinitesimal
Gauss-Newton steps towards the IK solution. Often the regularization
<span class="math notranslate nohighlight">\((I - J^\sharp J) (q_0 - q)\)</span> is also dropped, which is the same as
saying <span class="math notranslate nohighlight">\(q_0 = q\)</span>, i.e., you always set the homing state
<span class="math notranslate nohighlight">\(q_0\)</span> to be the current state <span class="math notranslate nohighlight">\(q\)</span>, adapting it on the fly.
Doing this, you will loose a precise definition of where you’ll
eventually converge to – and sometimes this leads to undesired <em>drift in
nullspace</em>. All not recommended.</p>
</section>
<section id="singularity">
<h5>Singularity.<a class="headerlink" href="#singularity" title="Link to this heading"></a></h5>
<p>The limit <span class="math notranslate nohighlight">\(C\to\infty\)</span> mentioned above is only robust when
<span class="math notranslate nohighlight">\(\det (J
J^{\!\top\!}) &gt; 0\)</span>, or equivalently, when <span class="math notranslate nohighlight">\(J\)</span> has full rank
(namely rank <span class="math notranslate nohighlight">\(d\)</span>). <span class="math notranslate nohighlight">\(J\)</span> is called singular otherwise, and the
pseudo inverse <span class="math notranslate nohighlight">\(J^\sharp\)</span> is ill-defined.</p>
<p>Intuitively this means that, in state <span class="math notranslate nohighlight">\(q\)</span>, certain task space
directions cannot be generated, i.e., no motion in these task space
directions is possible. A stretched arm that cannot extend further is a
typical example.</p>
<p>In the original NLP formulation, this corresponds to the case where
<span class="math notranslate nohighlight">\(\phi(q) = y^*\)</span> is simply infeasible, and a proper NLP-solver
should return this information.</p>
<p>The soft problem formulation ([eqSoft]), where <span class="math notranslate nohighlight">\(C\)</span>
is finite (not <span class="math notranslate nohighlight">\(\infty\)</span>) is one way to address a singularity: For
finite <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(J^\sharp\)</span> is well defined and defines steps
towards a optimal solution of the trade-off problem
([eqSoft]). This is also called <strong>regularized IK</strong> or
<strong>singularity-robust IK</strong>. But it only leads to an approximate IK
solution.</p>
</section>
</section>
</section>
</section>
<section id="d-transformations-rotations-quaternions">
<span id="apptransforms"></span><h2>3D Transformations, Rotations, Quaternions<a class="headerlink" href="#d-transformations-rotations-quaternions" title="Link to this heading"></a></h2>
<section id="rotations">
<h3>Rotations<a class="headerlink" href="#rotations" title="Link to this heading"></a></h3>
<p>There are many ways to represent rotations in <span class="math notranslate nohighlight">\(SO(3)\)</span>. We restrict
ourselves to three basic ones: rotation matrix, rotation vector, and
quaternion. The rotation vector is also the most natural representation
for a “rotation velocity” (angular velocities). Euler angles or
raw-pitch-roll are an alternative, but they have singularities and I
don’t recommend using them in practice.</p>
<dl>
<dt>A rotation matrix</dt><dd><p>is a matrix <span class="math notranslate nohighlight">\(R\in{\mathbb{R}}^{3\times3}\)</span> which is orthonormal
(columns and rows are orthogonal unit vectors, implying determinant
1). While a <span class="math notranslate nohighlight">\(3\times3\)</span> matrix has 9 degrees of freedom (DoFs),
the constraint of orthogonality and determinant 1 constraints this:
The set of rotation matrices has only 3 DoFs (<span class="math notranslate nohighlight">\(\sim\)</span> the local
Lie algebra is 3-dim).</p>
<ul class="simple">
<li><p>The application of <span class="math notranslate nohighlight">\(R\)</span> on a vector <span class="math notranslate nohighlight">\(x\)</span> is simply the
matrix-vector product <span class="math notranslate nohighlight">\(R x\)</span>.</p></li>
<li><p>Concatenation of two rotations <span class="math notranslate nohighlight">\(R_1\)</span> and <span class="math notranslate nohighlight">\(R_2\)</span> is the
normal matrix-matrix product <span class="math notranslate nohighlight">\(R_1 R_2\)</span>.</p></li>
<li><p>Inversion is the transpose,
<span class="math notranslate nohighlight">\(R^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} = R^{\!\top\!}\)</span>.</p></li>
</ul>
</dd>
<dt>A rotation vector</dt><dd><p>is an unconstrained vector <span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span>. The vector’s
direction <span class="math notranslate nohighlight">\(\underline w = \frac{w}{|w|}\)</span> determines the
rotation axis, the vector’s length <span class="math notranslate nohighlight">\(|w|=\theta\)</span> determines the
rotation angle (in radians, using the right thumb convention).</p>
<ul>
<li><p>The application of a rotation described by
<span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span> on a vector <span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^3\)</span>
is given as (Rodrigues’ formula)</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
w \cdot x
 &amp;= \cos\theta~ x
  + \sin\theta~ (\underline w\times x)
  + (1-\cos\theta)~ \underline w(\underline w^{\!\top\!}x)\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta=|w|\)</span> is the rotation angle and
<span class="math notranslate nohighlight">\(\underline w=w/\theta\)</span> the unit length rotation axis.</p>
</li>
<li><p>The inverse rotation is described by the negative of the rotation
vector.</p></li>
<li><p>Concatenation is non-trivial in this representation and we don’t
discuss it here. In practice, a rotation vector is first converted
to a rotation matrix or quaternion.</p></li>
<li><p>Conversion to a matrix: For every vector
<span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span> we define its skew symmetric matrix as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\hat w = \text{skew}(w) =  \left(\begin{array}{ccc}0 &amp; -w_3 &amp; w_2 \\ w_3 &amp; 0 &amp; -w_1 \\-w_2 &amp; w_1 &amp; 0\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Note that such skew-symmetric matrices are related to the cross
product: <span class="math notranslate nohighlight">\(w \times v = \hat w~ v\)</span>, where the cross product
is rewritten as a matrix product. The rotation matrix <span class="math notranslate nohighlight">\(R(w)\)</span>
that corresponds to a given rotation vector <span class="math notranslate nohighlight">\(w\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\label{eqRodriguez}
R(w)
 &amp;= \exp(\hat w) \\
 &amp;= \cos\theta~ I + \sin\theta~ \hat w/\theta+ (1-\cos\theta)~ w w^{\!\top\!}/\theta^2\end{aligned}\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(\exp\)</span> function is called exponential map (generating a
group element (=rotation matrix) via an element of the Lie algebra
(=skew matrix)). The other equation is called Rodrigues’ equation:
the first term is a diagonal matrix (<span class="math notranslate nohighlight">\(I\)</span> is the 3D identity
matrix), the second terms the skew symmetric part, the last term
the symmetric part (<span class="math notranslate nohighlight">\(w
w^{\!\top\!}\)</span> is also called outer product).</p>
</li>
</ul>
</dd>
<dt>Angular velocity &amp; derivative of a rotation matrix:</dt><dd><p>We represent angular velocities by a vector
<span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span>, the direction <span class="math notranslate nohighlight">\(\underline w\)</span>
determines the rotation axis, the length <span class="math notranslate nohighlight">\(|w|\)</span> is the rotation
velocity (in radians per second). When a body’s orientation at time
<span class="math notranslate nohighlight">\(t\)</span> is described by a rotation matrix <span class="math notranslate nohighlight">\(R(t)\)</span> and the
body’s angular velocity is <span class="math notranslate nohighlight">\(w\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqDotR}
\dot R(t) = \hat w~ R(t)~.\end{aligned}\]</div>
<p>(That’s intuitive to see for a rotation about the <span class="math notranslate nohighlight">\(x\)</span>-axis with
velocity 1.) Some insights from this relation: Since <span class="math notranslate nohighlight">\(R(t)\)</span>
must always be a rotation matrix (fulfill orthogonality and
determinant 1), its derivative <span class="math notranslate nohighlight">\(\dot R(t)\)</span> must also fulfill
certain constraints; in particular it can only live in a
3-dimensional sub-space. It turns out that the derivative
<span class="math notranslate nohighlight">\(\dot R\)</span> of a rotation matrix <span class="math notranslate nohighlight">\(R\)</span> must always be a skew
symmetric matrix <span class="math notranslate nohighlight">\(\hat w\)</span> times <span class="math notranslate nohighlight">\(R\)</span> – anything else would
be inconsistent with the constraints of orthogonality and determinant
1.</p>
<p>Note also that, assuming <span class="math notranslate nohighlight">\(R(0)=I\)</span>, the solution to the
differential equation <span class="math notranslate nohighlight">\(\dot R(t) = \hat w~ R(t)\)</span> can be written
as <span class="math notranslate nohighlight">\(R(t)=\exp(t \hat w)\)</span>, where here the exponential function
notation is used to denote a more general so-called exponential map,
as used in the context of Lie groups. It also follows that
<span class="math notranslate nohighlight">\(R(w)\)</span> from ([eqRodriguez]) is the rotation
matrix you get when you rotate for 1 second with angular velocity
described by <span class="math notranslate nohighlight">\(w\)</span>.</p>
</dd>
<dt>Quaternion</dt><dd><p>(I’m not describing the general definition, only the “quaternion to
represent rotation” definition.) A quaternion is a unit length 4D
vector <span class="math notranslate nohighlight">\(r\in{\mathbb{R}}^4\)</span>; the first entry <span class="math notranslate nohighlight">\(r_0\)</span> is
related to the rotation angle <span class="math notranslate nohighlight">\(\theta\)</span> via
<span class="math notranslate nohighlight">\(r_0=\cos(\theta/2)\)</span>, the last three entries
<span class="math notranslate nohighlight">\(\bar r\equiv r_{1:3}\)</span> are related to the unit length rotation
axis <span class="math notranslate nohighlight">\(\underline w\)</span> via
<span class="math notranslate nohighlight">\(\bar r = \sin(\theta/2)~ \underline w\)</span>.</p>
<ul>
<li><p>The inverse of a quaternion is given by negating <span class="math notranslate nohighlight">\(\bar r\)</span>,
<span class="math notranslate nohighlight">\(r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} =
(r_0,-\bar r)\)</span> (or, alternatively, negating <span class="math notranslate nohighlight">\(r_0\)</span>).</p></li>
<li><p>The concatenation of two rotations <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(r'\)</span> is given
as the quaternion product</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuat}
r \circ r'
 = (r_0 r'_0 - \bar r^{\!\top\!}\bar r',~
    r_0 \bar r' + r'_0 \bar r + \bar r' \times \bar r)\end{aligned}\]</div>
</li>
<li><p>The application of a rotation quaternion <span class="math notranslate nohighlight">\(r\)</span> on a vector
<span class="math notranslate nohighlight">\(x\)</span> can be expressed by converting the vector first to the
quaternion <span class="math notranslate nohighlight">\((0,x)\)</span>, then computing</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
r \cdot x = (r \circ (0,x) \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})_{1:3} ~,\end{aligned}\]</div>
<p>I think a bit more efficient is to first convert the rotation
quaternion <span class="math notranslate nohighlight">\(r\)</span> to the equivalent rotation matrix <span class="math notranslate nohighlight">\(R\)</span>:</p>
</li>
<li><p>Conversion to/from a matrix: A quaternion rotation <span class="math notranslate nohighlight">\(r\)</span>
convertes to the rotation matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
R
 &amp;=  \left(\begin{array}{ccc}
    1-r_{22}-r_{33} &amp; r_{12}-r_{03} &amp;    r_{13}+r_{02} \\
    r_{12}+r_{03} &amp;   1-r_{11}-r_{33} &amp;  r_{23}-r_{01} \\
    r_{13}-r_{02} &amp;   r_{23}+r_{01} &amp;    1-r_{11}-r_{22}
    \end{array}\right)  \\ &amp; ~ r_{ij} := 2 r_i r_j ~.\end{aligned}\end{split}\]</div>
<p>(Note: In comparison to ([eqRodriguez]) this
does not require to compute a <span class="math notranslate nohighlight">\(\sin\)</span> or <span class="math notranslate nohighlight">\(\cos\)</span>.)
Inversely, the quaternion <span class="math notranslate nohighlight">\(r\)</span> for a given matrix <span class="math notranslate nohighlight">\(R\)</span>
is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    r_0 &amp;= {\frac{1}{2}}\sqrt{1+{\rm tr}R}\\
    r_3 &amp;= (R_{21}-R_{12})/(4 r_0)\\
    r_2 &amp;= (R_{13}-R_{31})/(4 r_0)\\
    r_1 &amp;= (R_{32}-R_{23})/(4 r_0) ~.\end{aligned}\end{split}\]</div>
</li>
</ul>
</dd>
<dt>Angular velocity <span class="math notranslate nohighlight">\(\to\)</span> quaternion velocity</dt><dd><p>Given an angular velocity <span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span> and a current
quaternion <span class="math notranslate nohighlight">\(r(t)\in{\mathbb{R}}^4\)</span>, what is the time derivative
<span class="math notranslate nohighlight">\(\dot r(t)\)</span> (in analogy to Eq. ([eqDotR]))? For
simplicity, let’s first assume <span class="math notranslate nohighlight">\(|w|=1\)</span>. For a small time
interval <span class="math notranslate nohighlight">\(\delta\)</span>, <span class="math notranslate nohighlight">\(w\)</span> generates a rotation vector
<span class="math notranslate nohighlight">\(\delta w\)</span>, which converts to a quaternion</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\Delta r = (\cos(\delta/2), \sin(\delta/2) w) ~.\end{aligned}\]</div>
<p>That rotation is concatenated LHS to the original quaternion,</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
r(t+\delta)
 = \Delta r \circ r(t) ~.\end{aligned}\]</div>
<p>Now, if we take the derivative w.r.t. <span class="math notranslate nohighlight">\(\delta\)</span> and evaluate
it at <span class="math notranslate nohighlight">\(\delta=0\)</span>, all the <span class="math notranslate nohighlight">\(\cos(\delta/2)\)</span> terms become
<span class="math notranslate nohighlight">\(-\sin(\delta/2)\)</span> and evaluate to zero, all the
<span class="math notranslate nohighlight">\(\sin(\delta/2)\)</span> terms become <span class="math notranslate nohighlight">\(\cos(\delta/2)\)</span> and
evaluate to one, and we have</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuatVel}
\dot r(t)
&amp;= {\frac{1}{2}}( - w^{\!\top\!}\bar r,~  r_0 w + \bar r \times w )
 = {\frac{1}{2}}(0,w) \circ r(t)\end{aligned}\]</div>
<p>Here <span class="math notranslate nohighlight">\((0,w)\in{\mathbb{R}}^4\)</span> is a four-vector; for
<span class="math notranslate nohighlight">\(|w|=1\)</span> it is a normalized quaternion. However, due to the
linearity the equation holds for any <span class="math notranslate nohighlight">\(w\)</span>.</p>
</dd>
<dt>Quaternion velocity <span class="math notranslate nohighlight">\(\to\)</span> angular velocity</dt><dd><p>The following is relevant when taking the derivative
w.r.t. quaternion parameters, e.g., of a ball joint represented as
quaternion. Given <span class="math notranslate nohighlight">\(\dot r\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eq37}
\dot r \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
&amp;= {\frac{1}{2}}(0,w) \circ r \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} = {\frac{1}{2}}(0,w) ~,\quad w = 2~ [\dot r \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}]_{1:3}\end{aligned}\]</div>
<p>which allows us to read off the angular velocity <span class="math notranslate nohighlight">\(w\)</span> induced by
a change of quaternion <span class="math notranslate nohighlight">\(\dot r\)</span>. However, the RHS zero will
hold true only iff <span class="math notranslate nohighlight">\(\dot
r\)</span> is orthogonal to <span class="math notranslate nohighlight">\(r\)</span> (where
<span class="math notranslate nohighlight">\(\dot r^{\!\top\!}r = \dot r_0 r_0 + \dot{\bar
r}{}^{\!\top\!}\bar r = 0\)</span>, see ). In case
<span class="math notranslate nohighlight">\(\dot r^{\!\top\!}r \not=0\)</span>, the change in length of the
quaternion does not represent any angular velocity; in typical
kinematics engines a non-unit length is ignored. Therefore one first
orthogonalizes <span class="math notranslate nohighlight">\(\dot
r \gets \dot r - r(\dot r^{\!\top\!}r)\)</span>.</p>
<p>As a special case of application, consider computing the partial
derivative w.r.t. quaternion parameters, where <span class="math notranslate nohighlight">\(\dot r\)</span> is the
4D unit vectors <span class="math notranslate nohighlight">\(e_0,..,e_3\)</span>. In this case, the
orthogonalization becomes simply <span class="math notranslate nohighlight">\(\dot r \gets e_i - r r_i\)</span> and
([eq37]) becomes</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
(e_i - r_i r) \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
  &amp;= e_i \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} - r_i (1,0,0,0) ~,\quad
  w_i
 = 2~ [e_i \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}]_{1:3} ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span> is the rotation vector implied by
<span class="math notranslate nohighlight">\(\dot r = e_i\)</span>. In case the original quaternion <span class="math notranslate nohighlight">\(r\)</span>
wasn’t normalized (which could be, if a standard optimization
algorithm searches in the quaternion parameter space), then <span class="math notranslate nohighlight">\(r\)</span>
actually represents the normalized quaternion
<span class="math notranslate nohighlight">\(\bar r = \frac{1}{\sqrt{r^2}} r\)</span>, and (due to linearity of the
above), the rotation vector implied by <span class="math notranslate nohighlight">\(\dot r = e_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuatJac}
w_i
&amp;= \frac{2}{\sqrt{r^2}}~ [e_i \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}]_{1:3} ~.\end{aligned}\]</div>
<p>This defines a <span class="math notranslate nohighlight">\(3\times 4\)</span> <strong>quaternion Jacobian</strong>
<span class="math notranslate nohighlight">\(J_{:i} = w_i\)</span> with 4 columns <span class="math notranslate nohighlight">\(w_i\)</span>, so that
<span class="math notranslate nohighlight">\(w = J \dot r\)</span> is the angular velocity induced by a quaternion
velocity <span class="math notranslate nohighlight">\(\dot r\)</span> (accounting for all implicit normalizations).</p>
</dd>
</dl>
</section>
<section id="sectransformations">
<span id="id1"></span><h3>Transformations<a class="headerlink" href="#sectransformations" title="Link to this heading"></a></h3>
<p>We can represent a transformation as:</p>
<dl>
<dt>A homogeneous matrix</dt><dd><p>is a <span class="math notranslate nohighlight">\(4\times 4\)</span>-matrix of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
T =  \left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right) \end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is a <span class="math notranslate nohighlight">\(3\times 3\)</span>-matrix (rotation in our case)
and <span class="math notranslate nohighlight">\(t\)</span> a <span class="math notranslate nohighlight">\(3\)</span>-vector (translation).</p>
<p>In homogeneous coordinates, vectors <span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^3\)</span> are
expanded to 4D vectors
<span class="math notranslate nohighlight">\(\left(\begin{array}{c}x\\1\end{array}\right)  \in {\mathbb{R}}^4\)</span>
by appending a 1.</p>
<p>Application of a transform <span class="math notranslate nohighlight">\(T\)</span> on a vector
<span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^3\)</span> is then given as the normal matrix-vector
product</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
x' = T \cdot x
 &amp;= T~  \left(\begin{array}{c}x \\ 1\end{array}\right)
  =  \left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right) ~  \left(\begin{array}{c}x \\ 1\end{array}\right)
  =  \left(\begin{array}{c}Rx + t \\ 1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Concatenation is given by the ordinary 4-dim matrix-matrix product.</p>
<p>The inverse transform is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
 &amp;=  \left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right) ^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
  =  \left(\begin{array}{cc}R^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} &amp; -R^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} t \\ 0 &amp; 1\end{array}\right) \end{aligned}\end{split}\]</div>
</dd>
<dt>Translation and quaternion:</dt><dd><p>A transformation can efficiently be stored as a pair <span class="math notranslate nohighlight">\((t,r)\)</span> of
a translation vector <span class="math notranslate nohighlight">\(t\)</span> and a rotation quaternion <span class="math notranslate nohighlight">\(r\)</span>.
Analogous to the above, the application of <span class="math notranslate nohighlight">\((t,r)\)</span> on a vector
<span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(x' = t + r\cdot x\)</span>; the inverse is
<span class="math notranslate nohighlight">\((t,r)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} = (-r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\cdot t, r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})\)</span>;
the concatenation is
<span class="math notranslate nohighlight">\((t_1,r_1) \circ (t_2,r_2) = (t_1 + r_1\cdot t_2, r_1 \circ r_2)\)</span>.</p>
</dd>
<dt>Sequences of transformations</dt><dd><p>by <span class="math notranslate nohighlight">\(T_{A\to
B}\)</span> we denote the transformation from frame <span class="math notranslate nohighlight">\(A\)</span> to frame
<span class="math notranslate nohighlight">\(B\)</span>. The frames <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> can be thought of
coordinate frames (tuples of an offset (in an affine space) and three
local orthonormal basis vectors) attached to two bodies <span class="math notranslate nohighlight">\(A\)</span> and
<span class="math notranslate nohighlight">\(B\)</span>. It holds</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
T_{A\to C} = T_{A\to B} \circ T_{B\to C}\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\circ\)</span> is the concatenation described above. Let
<span class="math notranslate nohighlight">\(p\)</span> be a point (rigorously, in the affine space). We write
<span class="math notranslate nohighlight">\(p^A\)</span> for the coordinates of point <span class="math notranslate nohighlight">\(p\)</span> relative to frame
<span class="math notranslate nohighlight">\(A\)</span>; and <span class="math notranslate nohighlight">\(p^B\)</span> for the coordinates of point <span class="math notranslate nohighlight">\(p\)</span>
relative to frame <span class="math notranslate nohighlight">\(B\)</span>. It holds</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
p^A = T_{A\to B}~ p^B ~.\end{aligned}\]</div>
</dd>
</dl>
<section id="a-note-on-forward-vs-backward-of-frame-and-coordinate-transforms">
<span id="sectransnotation"></span><h4>A note on “forward” vs. “backward” of frame and coordinate transforms<a class="headerlink" href="#a-note-on-forward-vs-backward-of-frame-and-coordinate-transforms" title="Link to this heading"></a></h4>
<p>Instead of the notation <span class="math notranslate nohighlight">\(T_{A\to B}\)</span>, other text books often use
notations such as <span class="math notranslate nohighlight">\(T_{AB}\)</span> or <span class="math notranslate nohighlight">\(T^A_B\)</span>. A common question
regarding notation <span class="math notranslate nohighlight">\(T_{A\to B}\)</span> is the following:</p>
<blockquote>
<div><p><em>The notation :math:`T_{Ato B}` is confusing, since it transforms
coordinates from frame :math:`B` to frame :math:`A`. Why is the
notation not the other way around?</em></p>
</div></blockquote>
<p>I think the notation <span class="math notranslate nohighlight">\(T_{A\to B}\)</span> is intuitive for the following
reasons. The core is to understand that a transformation can be thought
of in two ways: as a transformation of the <em>coordinate frame itself</em>,
and as transformation of the <em>coordinates relative to a coordinate
frame</em>. I’ll first give a non-formal explanation and later more formal
definitions of affine frames and their transformation.</p>
<p>Think of <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> as translating and rotating a real rigid
body: First, the body is located at the world origin; then the body is
moved by a translation <span class="math notranslate nohighlight">\(t\)</span>; then the body is rotated (around its
own center) as described by <span class="math notranslate nohighlight">\(R\)</span>. In that sense,
<span class="math notranslate nohighlight">\(T_{W\to B} =  \left(\begin{array}{cc}R &amp; t \\ 0
&amp; 1\end{array}\right)\)</span> describes the “forward” transformation of the
body. Consider that a coordinate frame <span class="math notranslate nohighlight">\(B\)</span> is attached to the
rigid body and a frame <span class="math notranslate nohighlight">\(W\)</span> to the world origin. Given a point
<span class="math notranslate nohighlight">\(p\)</span> in the world, we can express its coordinates relative to the
world, <span class="math notranslate nohighlight">\(p^W\)</span>, or relative to the body <span class="math notranslate nohighlight">\(p^B\)</span>. You can
convince yourself with simple examples that
<span class="math notranslate nohighlight">\(p^W = T_{W\to B}~ p^B\)</span>, that is, <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> <em>also</em>
describes the “backward” transformation of body-relative-coordinates to
world-relative-coordinates.</p>
<p>Formally: Let <span class="math notranslate nohighlight">\((A,V)\)</span> be an affine space. A coordinate frame is a
tuple <span class="math notranslate nohighlight">\((o,\boldsymbol e_1,..,\boldsymbol e_n)\)</span> of an origin
<span class="math notranslate nohighlight">\(o \in A\)</span> and basis vectors <span class="math notranslate nohighlight">\(\boldsymbol e_i \in V\)</span>. Given a
point <span class="math notranslate nohighlight">\(p\in A\)</span>, its coordinates <span class="math notranslate nohighlight">\(p_{1:n}\)</span> w.r.t. a
coordinate frame <span class="math notranslate nohighlight">\((o,\boldsymbol e_1,..,\boldsymbol e_n)\)</span> are
given implicitly via</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
p = o + \sum\nolimits_i p_i \boldsymbol e_i ~.\end{aligned}\]</div>
<p>A transformation <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> is a (“forward”) transformation of
the coordinate frame itself:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
(o^B,\boldsymbol e^B_1,..,\boldsymbol e^B_n)
 &amp;= (o^W + t, R\boldsymbol e^W_1,..,R\boldsymbol e^W_n)\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(t\in V\)</span> is the affine translation in <span class="math notranslate nohighlight">\(A\)</span> and
<span class="math notranslate nohighlight">\(R\)</span> the rotation in <span class="math notranslate nohighlight">\(V\)</span>. Note that the coordinates
<span class="math notranslate nohighlight">\((\boldsymbol e^B_i)^W_{1:n}\)</span> of a basis vector
<span class="math notranslate nohighlight">\(\boldsymbol e^B_i\)</span> relative to frame <span class="math notranslate nohighlight">\(W\)</span> are the columns of
<span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\boldsymbol e^B_i
 &amp;= \sum_j (\boldsymbol e^B_i)^W_j \boldsymbol e^W_j
  = \sum_j R_{ji} \boldsymbol e^W_j\end{aligned}\]</div>
<p>Given this transformation of the coordinate frame itself, the
coordinates transform as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
p &amp;= o^W + \sum_i p^W_i~ \boldsymbol e^W_i \\
p &amp;= o^B + \sum_i p^B_i~ \boldsymbol e^B_i \\
  &amp;= o^W + t + \sum_i p^B_i~ (R \boldsymbol e^W_i) \\
  &amp;= o^W + \sum_i t^W_i~ e^W_i + \sum_j p^B_j~ (R \boldsymbol e^W_j) \\
  &amp;= o^W + \sum_i t^W_i~ e^W_i + \sum_j p^B_j~ (\sum_i R_{ij}~ \boldsymbol e^W_i) \\
  &amp;= o^W + \sum_i \Big[t^W_i + \sum_j R_{ij}~ p^B_j\Big]~ e^W_i \\
\Rightarrow
 &amp;~ p^W_i = t^W_i + \sum_j R_{ij}~ p^B_j ~.\end{aligned}\end{split}\]</div>
<p>Another way to express this formally: <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> maps
<em>covariant</em> vectors (including “basis vectors”) forward, but
<em>contra-variant</em> vectors (including “coordinates”) backward.</p>
</section>
</section>
</section>
<section id="splines">
<h2>Splines<a class="headerlink" href="#splines" title="Link to this heading"></a></h2>
<p>A spline is a piece-wise polynomial path
<span class="math notranslate nohighlight">\(x:[0,T] \to {\mathbb{R}}^n\)</span>. Let’s first clearly distinguish the
use of words <em>knot</em>, <em>waypoint</em>, and <em>control point</em>:</p>
<ul class="simple">
<li><p>A <strong>knot</strong> <span class="math notranslate nohighlight">\(t_i\)</span> is a point in <em>time</em>,
<span class="math notranslate nohighlight">\(t_i \in {\mathbb{R}}\)</span>, we assume <span class="math notranslate nohighlight">\(t_i \in [0,T]\)</span>. For a
spline, we have a non-decreasing sequence of knots <span class="math notranslate nohighlight">\(t_0,..,t_m\)</span>
(we assume <span class="math notranslate nohighlight">\(t_0=0\)</span> and <span class="math notranslate nohighlight">\(t_m=T\)</span>) which partition the time
interval <span class="math notranslate nohighlight">\([0,T]\)</span> into pieces
<span class="math notranslate nohighlight">\([t_i, t_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}}]\)</span> so
that the path is polynomial in each piece. Note that we may often
have double or triple knots, meaning that several consecutive knots
<span class="math notranslate nohighlight">\(t_i = t_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}}\)</span> are
equal, especially at the beginning and end.</p></li>
<li><p>A <strong>waypoint</strong> <span class="math notranslate nohighlight">\(x_i\)</span> is a point on the path, typically at a
knot, <span class="math notranslate nohighlight">\(x_i = x(t_i)\)</span>. So a path really passes through a
waypoint. At waypoints, we often also care about velocities
<span class="math notranslate nohighlight">\(v_i\)</span> and accelerations <span class="math notranslate nohighlight">\(\alpha_i\)</span>, where
<span class="math notranslate nohighlight">\(v_i = \dot x(t_i)\)</span>, <span class="math notranslate nohighlight">\(a_i = \ddot x(t_i)\)</span>, .</p></li>
<li><p>A <strong>control point</strong> <span class="math notranslate nohighlight">\(z_j\)</span> is (usually) not a point <em>on</em> the
path, but it indirectly defines the path as an linear combination of
several control points. B-splines, defined below, make this explicit.</p></li>
</ul>
<p>In robotics, there are two main conventions to define and parameterize
splines: Hermite splines and B-splines. Hermite splines are defined by
the knot sequence and explicitly prescribing waypoints <span class="math notranslate nohighlight">\(x_i\)</span> and
(for cubic) velocities <span class="math notranslate nohighlight">\(v_i\)</span> at each knot (for quintic also
acceperations <span class="math notranslate nohighlight">\(a_i\)</span>). In contrast, B-splines are specified by the
knot sequence and <span class="math notranslate nohighlight">\(K\)</span> control points <span class="math notranslate nohighlight">\(z_j\)</span>. As in B-splines
we do not need to provide velocities as part of the specification, they
are sometimes easier to use in practice. However, the resulting path
does not go (exactly) through the provided control points – the actual
waypoints are implicit and ensuring exact prescribed waypoints implies
solving a subproblem.</p>
<p>Cubic splines are a common choice in robotics, as they have a still
continuous (piece-wise linear) acceleration profile, and therefore
limited jerk (3rd time derivative).</p>
<p>In the following we first discuss a single cubic spline-piece as a means
of control, then Hermite splines, then B-splines.</p>
<section id="single-cubic-spline-for-timing-optimal-control-to-a-target">
<h3>Single cubic spline for timing-optimal control to a target<a class="headerlink" href="#single-cubic-spline-for-timing-optimal-control-to-a-target" title="Link to this heading"></a></h3>
<p>The following discusses a single cubic spline piece and and how to use
it for timing-optimal control to a target. Although very simple, the
method is a powerful alternative to typical PD-control to a target. It
also lays foundations on how timing-optimality can be realized with
Hermite splines.</p>
<p>Consider a cubic polynomial <span class="math notranslate nohighlight">\(x(t) = a t^3 + b t^2 + c t + d\)</span>.
Given four boundary conditions
<span class="math notranslate nohighlight">\(x(0)=x_0, \dot x(0) = v_0, x(\theta) = x_\theta, \dot x(\theta) = v_\theta\)</span>,
the four coefficients are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
d &amp;= x_0 ~, \\
c &amp;= \dot x_0 ~, \\
b &amp;= \frac{1}{\theta^2}\Big[ 3(x_\theta-x_0) - \theta(\dot x_\theta+ 2 \dot x_0) \Big] ~, \\
a &amp;= \frac{1}{\theta^3}\Big[ - 2(x_0-x_\theta) + \theta(\dot x_\theta+ \dot x_0) \Big] ~.\end{aligned}\end{split}\]</div>
<p>This cubic spline is in fact the solution to an optimization problem,
namely it is the path that minimizes accelerations between these
boundary conditions and it can therefore be viewed as the solution to
optimal control with acceleration costs:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\min_x~ \int_0^\tau \ddot x(t)^2~ dt
\quad~~\text{s.t.}~~ \left(\begin{array}{c}x(0)\\\dot x(0)\end{array}\right) = \left(\begin{array}{c}x_0\\v_0\end{array}\right) ,~
 \left(\begin{array}{c}x(\tau)\\\dot x(\tau)\end{array}\right) = \left(\begin{array}{c}x_1\\v_1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>The minimal costs can analytically be given as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\int_0^T \ddot x(t)^2 dt
%% &amp;= \int_0^T (6 a t + 2 b)^2 ~ dt \\
%% &amp;= \int_0^T (36 a^2 t^2 + 4 b^2 + 24 abt) ~ dt \\
%% &amp;= 4 b^2 [t]_0^T + 24 ab [\half t^2]_0^T + 36 a^2 [\frac{1}{3} t^3]_0^T \\
&amp;= 4 \tau b^2  + 12 \tau^2 ab + 12 \tau^3 a^2 \\
&amp;= \frac{12}{\tau^3}~[(x_1 - x_0)-\frac{\tau}{2}(v_0+v_1)]^2+\frac{1}{\tau}(v_1-v_0)^2 \label{eqLeap}\\
&amp;= \frac{12}{\tau^3} D^{\!\top\!}D + \frac{1}{\tau} V^{\!\top\!}V ~,\quad D := (x_1 - x_0)-\frac{\tau}{2}(v_0+v_1),~ V:=v_1-v_0,~ \\
&amp;= \tilde D^{\!\top\!}\tilde D + \tilde V^{\!\top\!}\tilde V ~,\quad
\tilde D := \sqrt{12}~ \tau^{-\frac{3}{2}}~ D,~ \tilde V := \tau^{-{\frac{1}{2}}}~ V ~,
\label{eqLeapSOS}\end{aligned}\end{split}\]</div>
<p>where we used some help of computer algebra to get this right.</p>
<p>Eq. ([eqLeap]) explicitly gives the optimal cost in
terms of boundary conditions <span class="math notranslate nohighlight">\((x_0,v_0,x_1,v_1)\)</span> and time
<span class="math notranslate nohighlight">\(\tau\)</span>. This is a very powerful means to optimize boundary
conditions and <span class="math notranslate nohighlight">\(\tau\)</span>. The following is a simple application that
realizes reactive control.</p>
<section id="single-piece-optimal-timing-control">
<h4>Single-piece optimal timing control<a class="headerlink" href="#single-piece-optimal-timing-control" title="Link to this heading"></a></h4>
<p>Consider the system is in state <span class="math notranslate nohighlight">\((x,\dot x)\)</span> and you want to
control it to a reference point
<span class="math notranslate nohighlight">\((x_\text{ref}, \dot x_\text{ref}=0)\)</span>. An obvious approach would
be to use a PD law
<span class="math notranslate nohighlight">\(\ddot x_\text{des}= k_p (x_\text{ref}- x) + k_d (\dot x_\text{ref}- \dot x)\)</span>
and translate <span class="math notranslate nohighlight">\(\ddot x_\text{des}\)</span> to controls using inverse
dynamics. By choosing <span class="math notranslate nohighlight">\(k_p\)</span> and <span class="math notranslate nohighlight">\(k_d\)</span> appropriately one can
generate any desired damped/oscillatory-exponential approach behavior
(section [secPD] derives the necessary equations).</p>
<p>However, while PD laws are fundamental for low-level optimal control
under noise (e.g. as result of the Riccati equation), they are actually
not great for generating more macroscopic approach behavior: They are
“only” exponentially converging, never really reaching the target in a
definite time, never providing a clear expected time-to-target. And
accelerations seem intuitively too large when far from the set point,
and too small when close. (Which is why many heuristics, such as capped
PD laws were proposed.)</p>
<p>Instead of imposing a desired PD behavior, we can impose a desired cubic
spline behavior, which leads to succinct convergence in a finite
expected time-to-target, as well as moderate gains when far. The
approach is simply to choose an optimal <span class="math notranslate nohighlight">\(\tau\)</span> (time-to-target)
that minimizes</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{\tau, x}~ \alpha\tau + \int_0^\tau \ddot x(t)^2~ dt\end{aligned}\]</div>
<p>under our boundary conditions, assuming a cubic spline
<span class="math notranslate nohighlight">\(x(t), t\in[0,\tau]\)</span>. Using ([eqLeap]), we know the
optimal <span class="math notranslate nohighlight">\(x\)</span> and optimal control costs for given <span class="math notranslate nohighlight">\(\tau\)</span>. When
<span class="math notranslate nohighlight">\(\delta= x_\text{ref}- x\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are co-linear (i.e., the
system moves towards the target), computer algebra can tell us the
optimal <span class="math notranslate nohighlight">\(\tau\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqTimingControl}
  \tau^* = \frac{1}{\alpha}\Big[ \sqrt{6 |\delta| \alpha+ v^2} - |v| \Big] ~.\end{aligned}\]</div>
<p>If the system has a lateral movement, the analytical solution seems
overly complex, but a numerical solution to the least-squares form
([eqLeapSOS]) very efficient. However, in practise,
using ([eqTimingControl]) with scalar
<span class="math notranslate nohighlight">\(v \gets (\delta^{\!\top\!}v)/|\delta|\)</span> for easy timing control of
convergence to a target is highly efficient and versatile.</p>
<p>To make this a reactive control scheme, in each control cycle
<span class="math notranslate nohighlight">\(\tau^*\)</span> is reevaluated and the corresponding cubic spline
reference send to low-level control. If there are no perturbations, the
estimated <span class="math notranslate nohighlight">\(\tau^*\)</span> will be the true time-to-target. See
<a href="#id2"><span class="problematic" id="id3">:raw-latex:`\cite{22-toussaint-SecMPC}`</span></a> for details and comparision to
PD approach behavior.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">moveTo</span></code> method of <code class="docutils literal notranslate"><span class="pre">BotOP</span></code> uses exactly this scheme to realize
reactive control.</p>
</section>
</section>
<section id="hermite-cubic-splines">
<h3>Hermite Cubic Splines<a class="headerlink" href="#hermite-cubic-splines" title="Link to this heading"></a></h3>
<p>A Hermite cubic spline is specified by the series of non-decreasing time
knots, <span class="math notranslate nohighlight">\(t_0,..,t_m \in [0,T]\)</span>, <span class="math notranslate nohighlight">\(t_0=0, t_m=T\)</span>, and the
waypoints <span class="math notranslate nohighlight">\(x_i\)</span> <em>and velocities</em> <span class="math notranslate nohighlight">\(v_i\)</span> at each time knot.
There are not double knots, so the interval <span class="math notranslate nohighlight">\([0,T]\)</span> is split in
<span class="math notranslate nohighlight">\(m\)</span> cubic pieces, where the <span class="math notranslate nohighlight">\(i\)</span>th piece is determined by
the boundary conditions
<span class="math notranslate nohighlight">\((x_{i{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}},v_{i{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}, x_i, v_i)\)</span>
and
<span class="math notranslate nohighlight">\(\tau_i = t_i - t_{i{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}\)</span>.</p>
<p>Specifying the timings (i.e., knots) and velocities of all waypoints is
often not easy in terms of a user interface. Therefore the question is
whether a series of given weypoints can easily be augmented with optimal
timings and waypoint velocities.</p>
<p>Further, since each piece respects boundary conditions, continuity in
velocities is ensured. However, note that two pieces might have
completely different accelerations at their joining knots (from the left
and the right), and therefore a freely specified Hermite cubic spline is
discontinuous in acceleration (has infintite jerk). Conversely,
requiring a path in <span class="math notranslate nohighlight">\({\cal C}^2\)</span> implies continuity constraints in
acceleration at each knot. Over the full path, these are
<span class="math notranslate nohighlight">\((m{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}) \cdot n\)</span>
constraints (in <span class="math notranslate nohighlight">\({\mathbb{R}}^n\)</span>), which “kill” the
degrees-of-freedom of all but the start and end velocity. Therefore,
requiring continuous accelleration, the kots, waypoints and start/end
velocity alone are sufficient to specify the spline – but in practise
the resulting waypoint velocities might not be quite desired, as they
might “go crazy” when chaining forward the continuous acceleration
constraint.</p>
<p>However, optimizing both, timing and waypoint velocities under out
optimal control objective is rather efficient and effective. Note that
the optimal control cost over the full spline is just the sum of single
piece costs ([eqLeapSOS]). This represents costs as a
least-squares of differentiable features, where <span class="math notranslate nohighlight">\(D\)</span> can be
interpreted as distance to be covered by accelerations, and <span class="math notranslate nohighlight">\(V\)</span> as
necessary total acceleration, and the Jacobians of <span class="math notranslate nohighlight">\(\tilde D\)</span> and
<span class="math notranslate nohighlight">\(\tilde V\)</span> w.r.t. all boundary conditions and <span class="math notranslate nohighlight">\(\tau_i\)</span> are
trivial. Exploiting the least-squares formulation of <span class="math notranslate nohighlight">\(\psi\)</span> we can
use the Gauss-Newton approximate Hessian.</p>
<p>As a concequence, it is fairly efficient to solve for
<span class="math notranslate nohighlight">\(\tau_{1:m}\)</span>,
<span class="math notranslate nohighlight">\(v_{1:m{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}\)</span> given
<span class="math notranslate nohighlight">\(v_0, v_m, x_{0:m}\)</span> under continuous acceleration constraints
subject to total time and control costs.</p>
<p>The C++ code implementes this with the <code class="docutils literal notranslate"><span class="pre">TimingOpt</span></code> class, leverging
our standard AugLag method and the least-squares formulation
([eqLeapSOS]).</p>
<p>As a final note, in Hermite quintic splines we need positions
<span class="math notranslate nohighlight">\(x_i\)</span>, velocities <span class="math notranslate nohighlight">\(v_i\)</span> and accelerations <span class="math notranslate nohighlight">\(a_i\)</span> at
each knot, which describe the quintic polynomial pieces between knots.
The issues discussed above apply here analogously.</p>
</section>
<section id="b-splines">
<h3>B-Splines<a class="headerlink" href="#b-splines" title="Link to this heading"></a></h3>
<p>In B-splines, the path <span class="math notranslate nohighlight">\(x: [0,T] \to {\mathbb{R}}^n\)</span> is expressed
as a linear combination of control points
<span class="math notranslate nohighlight">\(z_0,.., z_K \in {\mathbb{R}}^n\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{bspline}
x(t) = \sum_{i=0}^K B_{i,p}(t)~ z_i ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(B_{i,p}: {\mathbb{R}}\to {\mathbb{R}}\)</span> maps the time
<span class="math notranslate nohighlight">\(t\)</span> to the weighting of the <span class="math notranslate nohighlight">\(i\)</span>th control point – it
blends in and out the <span class="math notranslate nohighlight">\(i\)</span>th control point. For any <span class="math notranslate nohighlight">\(t\)</span> it
holds that <span class="math notranslate nohighlight">\(\sum_{i=0}^K B_{i,p}(t) = 1\)</span>, i.e., all the weights
<span class="math notranslate nohighlight">\(B_{i,p}(t)\)</span> sum to one (as with a probability distribution over
<span class="math notranslate nohighlight">\(i\)</span>), and the path point <span class="math notranslate nohighlight">\(x(t)\)</span> is therefore always in the
convex hull of control points.</p>
<p>Concerning terminology, actually the functions <span class="math notranslate nohighlight">\(B_{i,p}(t)\)</span> are
called <strong>B-splines</strong>, not the resulting path <span class="math notranslate nohighlight">\(x(t)\)</span>. (But in
everyday robotics language, one often calls the path a B-spline.) As the
linear (scalar) product in ([bspline]) is trivial, the
maths (and complexity of code) is all about the B-splines
<span class="math notranslate nohighlight">\(B_{i,p}(t)\)</span>, not the path <span class="math notranslate nohighlight">\(x(t)\)</span>.</p>
<p>The B-spline functions <span class="math notranslate nohighlight">\(B_{i,p}(t)\)</span> are fully specified by a
non-decreasing series of time knots <span class="math notranslate nohighlight">\(t_0,..,t_m \in [0,T]\)</span> and the
integer degree <span class="math notranslate nohighlight">\(p\in\{0,1,..\}\)</span>. Namely, the recursive definition
is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
B_{i,0}(t) &amp;= [t_i \le t &lt; t_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}}] ~,\quad\text{for $0\le i \le m-1$} ~,\\
B_{i,p}(t)
&amp;= \frac{t-t_i}{t_{i+p}-t_i}~ B_{i,p-1}(t)
 +  \frac{t_{i+p+1}-t}{t_{i+p+1}-t_{i+1}}~ B_{i+1,p-1}(t)  ~,\quad\text{for $0\le i \le m-p-1$} ~.\end{aligned}\end{split}\]</div>
<p>The zero-degree B-spline functions <span class="math notranslate nohighlight">\(B_{i,0}\)</span> are indicators of
<span class="math notranslate nohighlight">\(t_i \le t &lt; t_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}}\)</span>,
and <span class="math notranslate nohighlight">\(i\)</span> ranges from <span class="math notranslate nohighlight">\(i=0,..,m-1\)</span>. The 1st-degree B-spline
functions <span class="math notranslate nohighlight">\(B_{i,1}\)</span> have support in <span class="math notranslate nohighlight">\(t_i \le t &lt; t_{i+2}\)</span>
and <span class="math notranslate nohighlight">\(i\)</span> only ranges in <span class="math notranslate nohighlight">\(i=0,..,m-2\)</span> – because one can show
that the normalization <span class="math notranslate nohighlight">\(\sum_{i=0}^{m-2} B_{i,1}(t) = 1\)</span> holds
(and for <span class="math notranslate nohighlight">\(i&gt;m-2\)</span>, the recursion would also not be clearly
defined). In general, degree <span class="math notranslate nohighlight">\(p\)</span> B-spline functions
<span class="math notranslate nohighlight">\(B_{i,p}\)</span> have support in <span class="math notranslate nohighlight">\(t_i \le t &lt; t_{i+p+1}\)</span> and
<span class="math notranslate nohighlight">\(i\)</span> ranges from <span class="math notranslate nohighlight">\(i=0,..,m+p-1\)</span>, which is why we need
<span class="math notranslate nohighlight">\(K+1\)</span> control points <span class="math notranslate nohighlight">\(z_{0:K}\)</span> with</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
    K = m+p-1 ~,
  \end{aligned}\]</div>
<p>which ensures the normalization property
<span class="math notranslate nohighlight">\(\sum_{i=0}^K B_{i,p}(t) = 1\)</span> for every degree.</p>
<p><a href="#id8"><span class="problematic" id="id9">|image|</span></a></p>
<p>[figSplines] Illustration of B-spline functions for degrees
<span class="math notranslate nohighlight">\(p=0,..,4\)</span>. Above each plot of functions, a rough illustration of
a resulting spline is provided, where bullets indicate control points.
Note that this illustration implies a localization of control points in
time, namely roughly where the coresponding weighting function (B-spline
function) is highest – but control points are formally not localized in
time, they are just being linearly combined,
<span class="math notranslate nohighlight">\(x(t) = \sum_{i=0}^K B_{i,p}(t)~ z_i\)</span>, with different weighting in
time. However, intuitively we can see that for odd degrees, the
“localization in time” of control points roughly aligns with knots,
while for even degrees the localization is between knots. Further, the
illustrations assume multi-knots at the start and end (namely
<span class="math notranslate nohighlight">\(p{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}\)</span>-fold knots),
which ensures that the spline starts with <span class="math notranslate nohighlight">\(z_0\)</span> and ends with
<span class="math notranslate nohighlight">\(z_K\)</span>. Multiple equal control points <span class="math notranslate nohighlight">\(z_{0:p}\)</span> and
<span class="math notranslate nohighlight">\(z_{K-p:K}\)</span> (illustrated with gray bars) are needed to ensure also
zero vel/acc/jerk at start and end.</p>
<section id="b-spline-matrix-for-time-discretized-paths">
<h4>B-spline Matrix for Time Discretized Paths<a class="headerlink" href="#b-spline-matrix-for-time-discretized-paths" title="Link to this heading"></a></h4>
<p>Splines describe a continuous path <span class="math notranslate nohighlight">\(x(t)\)</span>, but often we want to
evaluate this path only at a finite number of time slices
<span class="math notranslate nohighlight">\(t\in \{\widehat t_1,..,\widehat t_S\} \subset [0,T]\)</span>. E.g., this
could be a grid of <span class="math notranslate nohighlight">\(S=100\)</span> time slices over which we want to
optimize using KOMO, and for which we have to compute collision
features. Let <span class="math notranslate nohighlight">\(x \in {\mathbb{R}}^{S \times n}\)</span> be the time
discretized path, and
<span class="math notranslate nohighlight">\(z \in{\mathbb{R}}^{K{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}\times n}\)</span>
be the stack of control points. Then the B-spline representation becomes</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
x = B_p z ~,\quad\text{with } B_p\in{\mathbb{R}}^{S\times K{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}},~ B_{p,si} = B_{i,p}(\widehat t_s) ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(B_p\)</span> is the B-spline matrix of degree <span class="math notranslate nohighlight">\(p\)</span> for this
particular time grid <span class="math notranslate nohighlight">\(\{\widehat t_1,..,\widehat t_S\}\)</span>.</p>
<p>So whenever we have a problem (e.g., NLP) defined over the fine
resolution samples <span class="math notranslate nohighlight">\(x_s\)</span>, the B-spline matrix provides a linear
re-parameterization and it is trivial to pull gradients (and Hessians)
back to define a problem over <span class="math notranslate nohighlight">\(z\)</span>. In our code, KOMO defines NLPs
over trajectories – it is trivial to wrap this with a linear B-spline
parameterization to then imply a much lower-dimensional NLP over the
control points <span class="math notranslate nohighlight">\(z\)</span>.</p>
</section>
<section id="ensuring-b-splines-pass-through-waypoints">
<h4>Ensuring B-splines pass through waypoints<a class="headerlink" href="#ensuring-b-splines-pass-through-waypoints" title="Link to this heading"></a></h4>
<p>As we emphasized, the control point parameterization is not necessarily
intuitive for a user, as the resulting path does not transition through
control points. If a user provides a series of waypoints at desired
times <span class="math notranslate nohighlight">\(\widehat t_s\)</span>, how can we construct a B-spline to ensure
transitioning through these waypoints at the desired times?</p>
<p>The answer is again the matrix equation. Consider the cubic spline case
and that the start and end points and times are fixed. Therefore
<span class="math notranslate nohighlight">\(z_{0:1}\)</span> and
<span class="math notranslate nohighlight">\(z_{K{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}:K}\)</span>, as well as
knots <span class="math notranslate nohighlight">\(t_{0:3}\)</span> and <span class="math notranslate nohighlight">\(t_{m-3:m}\)</span> are fixed. The user wants
waypoints <span class="math notranslate nohighlight">\(x_1,..,x_S\)</span> at times
<span class="math notranslate nohighlight">\(\widehat t_1,..,\widehat t_S\)</span> <em>between</em> start and end.</p>
<p>We can distribute <span class="math notranslate nohighlight">\(S\)</span> knots <span class="math notranslate nohighlight">\(t_{4:3+S}\)</span> uniformly between
start and end knots (or also at <span class="math notranslate nohighlight">\(\widehat t_1,..,\widehat t_S\)</span>),
from which it follows we have <span class="math notranslate nohighlight">\(m = S+7\)</span>, and <span class="math notranslate nohighlight">\(K=m-p-1=S+3\)</span>,
which are <span class="math notranslate nohighlight">\(K+1=S+4\)</span> control points in total, of which <span class="math notranslate nohighlight">\(4\)</span>
are already fixed. So the <span class="math notranslate nohighlight">\(S\)</span> middle control points are still
free, and matrix inversion gives them from the desired waypoints,</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
  z_{2:S+1} = B^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} x_{1:S} ~,\quad\text{with } B \in {\mathbb{R}}^{S \times S},~ B_{si} =  B_{i+1,3}(\widehat t_s),~ s,i=1,..,S  ~.
  \end{aligned}\]</div>
</section>
<section id="ensuring-boundary-velocities">
<h4>Ensuring boundary velocities<a class="headerlink" href="#ensuring-boundary-velocities" title="Link to this heading"></a></h4>
<p>Consider again an online control situation where the is in state
<span class="math notranslate nohighlight">\((x,\dot x)\)</span> and we want to steer it through future waypoints. In
the B-spline representation we have to construct a spline that starts
with current state as starting boundary.</p>
<p>For degrees 2 and 3 this is simple to achieve: In both cases we usually
have <span class="math notranslate nohighlight">\(z_0=z_1\)</span> and
<span class="math notranslate nohighlight">\(z_{K{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}=z_K\)</span> to ensure
zero start and end velocities. Modifying <span class="math notranslate nohighlight">\(z_1\)</span> directly leads to
the start velocity
<span class="math notranslate nohighlight">\(\dot x(0) = \dot B_{0,p}(0) z_0 + \dot B_{1,p}(0) z_1\)</span>. But
because of normalization we have
<span class="math notranslate nohighlight">\(\dot B_{0,p}(0) = - \dot B_{1,p}(0)\)</span>, and therefore</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \dot x(0) &amp;= \dot B_{0,p}(0) (z_0 - z_1) \\
  z_1 &amp;= z_0 - \frac{\dot x(0)}{\dot B_{0,p}(0)} ~.\end{aligned}\end{split}\]</div>
</section>
<section id="gradients">
<h4>Gradients<a class="headerlink" href="#gradients" title="Link to this heading"></a></h4>
<p>The gradients of a B-spline represented path w.r.t. control points are
trivial. But the gradients w.r.t. the knots are less trivial. Here the
basic equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
B_{i,p}(t)
  &amp;= \frac{t-t_i}{t_{i+p}-t_i} B_{i,p-1}(t)
 +  \frac{t_{i+p+1}-t}{t_{i+p+1}-t_{i+1}} B_{i+1,p-1}(t) \\
&amp;=: v~ B_{i,p-1} + w~ B_{i+1,p-1} \\
\dot B_{i,p}(t)
 &amp;= \frac{1}{t_{i{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}{}p}-t_i}~ B_{i,p{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}(t)
 + v~ \dot B_{i,p{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}(t)
 - \frac{1}{t_{i{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}{}p{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}}-t_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}}}~ B_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1},p{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}(t)
 + w~ \dot B_{i{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1},p{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}}(t) \\
\partial_{t_i} B_{i,p}
  &amp;= \Big[\frac{-1}{t_{i+p}-t_i} + \frac{t-t_i}{(t_{i+p}-t_i)^2}\Big]~ B_{i,p-1}
   + v~ \partial_{t_i} B_{i,p-1} + w~ \partial_{t_i} B_{i+1,p-1} \\
  &amp;= \Big[\frac{-1}{t-t_i} + \frac{1}{t_{i+p}-t_i} \Big]~ v~ B_{i,p-1} + v~ \partial_{t_i} B_{i,p-1} + w~ \partial_{t_i} B_{i+1,p-1} \\
\partial_{t_{i+1}} B_{i,p}
  &amp;= \Big[\frac{1}{t_{i+p+1}-t_{i+1}}\Big]~ w~ B_{i+1,p-1}
      + v~ \partial_{t_{i+1}}~ B_{i,p-1} + w~ \partial_{t_{i+1}}~ B_{i+1,p-1} \\
\partial_{t_{i+p}} B_{i,p}
  &amp;= \Big[- \frac{1}{t_{i+p}-t_{i}}\Big]~ v~ B_{i,p-1}
      + v~ \partial_{t_{i+p}}~ B_{i,p-1} + w~ \partial_{t_{i+p}}~ B_{i+1,p-1} \\
\partial_{t_{i+p+1}} B_{i,p}
  &amp;= \Big[\frac{1}{t_{i+p+1}-t} - \frac{1}{t_{i+p+1}-t_{i+1}}\Big]~ w~ B_{i+1,p-1}
      + v~ \partial_{t_{i+p+1}}~ B_{i,p-1} + w~ \partial_{t_{i+p+1}}~ B_{i+1,p-1}\end{aligned}\end{split}\]</div>
</section>
</section>
</section>
<section id="code-references">
<h2>Code References<a class="headerlink" href="#code-references" title="Link to this heading"></a></h2>
<section id="nlp-interface">
<span id="secnlp"></span><h3>NLP interface<a class="headerlink" href="#nlp-interface" title="Link to this heading"></a></h3>
<p>A general non-linear mathematical program (NLP) is of the form</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ f(x) ~~~\text{s.t.}~~~ g(x)\le 0,~ h(x) = 0  ~,\end{aligned}\]</div>
<p>with <span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^n\)</span>,
<span class="math notranslate nohighlight">\(f:~ {\mathbb{R}}^n \to {\mathbb{R}}\)</span>,
<span class="math notranslate nohighlight">\(g:~ {\mathbb{R}}^n \to {\mathbb{R}}^{d_g}\)</span>,
<span class="math notranslate nohighlight">\(h:~ {\mathbb{R}}^n \to {\mathbb{R}}^{d_h}\)</span>,
<span class="math notranslate nohighlight">\(b_l,b_u\in{\mathbb{R}}^n\)</span>. However, we want to explicitly account
for <strong>least squares</strong> costs (sum-of-squares), so that we extend the form
to</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ f(x) + r(x)^{\!\top\!}r(x) ~~~\text{s.t.}~~~ g(x)\le 0,~ h(x) = 0  ~,\end{aligned}\]</div>
<p>with <span class="math notranslate nohighlight">\(r:~ {\mathbb{R}}^n \to {\mathbb{R}}^{d_r}\)</span>. In technical
terms, the solver needs to be provided with:</p>
<ul class="simple">
<li><p>the problem “signature”: dimension <span class="math notranslate nohighlight">\(n\)</span>, dimensions
<span class="math notranslate nohighlight">\(d_r, d_g, d_h\)</span>, bounds <span class="math notranslate nohighlight">\(b_l, b_u \in {\mathbb{R}}^n\)</span>,</p></li>
<li><p>functions <span class="math notranslate nohighlight">\(f, r, g, h\)</span>,   Jacobians for all,   Hessian for
<span class="math notranslate nohighlight">\(f\)</span>,</p></li>
<li><p>typically also an initialization sampler <span class="math notranslate nohighlight">\(x_0 \sim p(x)\)</span>, that
provides starting <span class="math notranslate nohighlight">\(x_0\)</span>.</p></li>
</ul>
<p>However, instead of providing a solver with separate functions
<span class="math notranslate nohighlight">\(f, r, g, h\)</span>, we instead provide only a single differentiable
<strong>feature</strong> function <span class="math notranslate nohighlight">\(\phi: X \to {\mathbb{R}}^K\)</span>, which stacks
all <span class="math notranslate nohighlight">\(f,r,g,h\)</span> components to a single vector,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\phi(x) =  \left(\begin{array}{c}f_1(x) \\ r_1(x) \\ h_1(x) \\ g_1(x) \\ h_2(x) \\ \vdots\end{array}\right)
~,\quad
\rho =  \left(\begin{array}{c}\texttt{f}\\ \texttt{sos}\\ \texttt{eq}\\ \texttt{ineq}\\ \texttt{eq}\\ \vdots\end{array}\right)  ~,\end{aligned}\end{split}\]</div>
<p>where the indicator vector <span class="math notranslate nohighlight">\(\rho\)</span> informs the solver which
components of <span class="math notranslate nohighlight">\(\phi\)</span> have to be treated as linear cost (<code class="docutils literal notranslate"><span class="pre">f</span></code>),
sum-of-squares cost (<code class="docutils literal notranslate"><span class="pre">sos</span></code>), equality constraint (<code class="docutils literal notranslate"><span class="pre">eq</span></code>), or
inequality constraint (<code class="docutils literal notranslate"><span class="pre">ineq</span></code>). (The order of stacking does not
matter.) In this convention, the NLP reads</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ {{\bf 1}}^{\!\top\!}\phi_\texttt{f}(x) + \phi_\texttt{sos}(x)^{\!\top\!}\phi_\texttt{sos}(x)
  ~~\text{s.t.}~~\phi_\texttt{ineq}(x) \le 0,~ \phi_\texttt{eq}(x) = 0 ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_\texttt{sos}\)</span> is the subsets of <code class="docutils literal notranslate"><span class="pre">sos</span></code>-features, etc.
Based on these conventions, the solver needs to be provided with:</p>
<ul class="simple">
<li><p>the problem “signature”: dimension <span class="math notranslate nohighlight">\(n\)</span>, feature types
<span class="math notranslate nohighlight">\(\rho\)</span>, bounds <span class="math notranslate nohighlight">\(b_l, b_u \in {\mathbb{R}}^n\)</span>,</p></li>
<li><p>a single differentiable <strong>feature</strong> function
<span class="math notranslate nohighlight">\(\phi: X \to {\mathbb{R}}^K\)</span>, with Jacobian function
<span class="math notranslate nohighlight">\(J = \partial_x \phi(x)\)</span>,</p></li>
<li><p>optionally a Hessian function for the sum of all <code class="docutils literal notranslate"><span class="pre">f</span></code>-terms,</p></li>
<li><p>and typically also an initialization sampler <span class="math notranslate nohighlight">\(x_0 \sim p(x)\)</span>,
that provides starting <span class="math notranslate nohighlight">\(x_0\)</span>.</p></li>
</ul>
<p>In the rai code, an NLP is therefore declared as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">signature</span>
<span class="n">uint</span> <span class="n">dimension</span><span class="p">;</span>  <span class="n">ObjectiveTypeA</span> <span class="n">featureTypes</span><span class="p">;</span>  <span class="n">arr</span> <span class="n">bounds_lo</span><span class="p">,</span> <span class="n">bounds_up</span><span class="p">;</span>

<span class="o">//</span><span class="n">essential</span> <span class="n">method</span>
<span class="n">virtual</span> <span class="n">void</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">arr</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">J</span><span class="p">,</span> <span class="n">const</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

<span class="o">//</span><span class="n">optional</span>
<span class="n">virtual</span> <span class="n">arr</span>  <span class="n">getInitializationSample</span><span class="p">(</span><span class="n">const</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">previousOptima</span><span class="o">=</span><span class="p">{});</span>
<span class="n">virtual</span> <span class="n">void</span> <span class="n">getFHessian</span><span class="p">(</span><span class="n">arr</span><span class="o">&amp;</span> <span class="n">H</span><span class="p">,</span> <span class="n">const</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="yaml-graph-files">
<span id="secyamlgraph"></span><h3>Yaml-Graph Files<a class="headerlink" href="#yaml-graph-files" title="Link to this heading"></a></h3>
<p>We use yaml-style files throughout. These are the file representation of
internal data structures such as dictionaries (anytype key-value maps)
used for parameter files or other structure data, but esp. also graphs.
The (semantic) extensions relative to yaml are:</p>
<ul class="simple">
<li><p>An &#64;Include&#64; node allows to hierarchically include files. This means
that while each local file can be parsed with a standard yaml parser,
an outer loop has to check for &#64;Include&#64; nodes and coordinate loading
sub-files.</p></li>
<li><p>As an implication of the above, we allow for a special &#64;path&#64; type,
as URLs embraced by <code class="docutils literal notranslate"><span class="pre">&lt;...&gt;</span></code>. This becomes necessary as file values
need to be interpreted relative to the path of the loading file. So
when such a file is parsed we not only store the filename string, but
also the path of the loading file to ensure we know its absolute
path.</p></li>
<li><p>We also allow &#64;Edit&#64; and &#64;Delete&#64; tags, which allow us to
edit/overwrite the value of previously defined nodes, as well as
delete previously defined nodes.</p></li>
<li><p>Finally, the name of a node can include a list of parents: E.g. &#64;A (B
C): shape: box&#64; denotes a node with key &#64;A&#64; that is a child of &#64;B&#64;
and &#64;C&#64;. The semantics of this is that &#64;A&#64; is a (directed) edge
between B and C. This is analogous to a dot declaration &#64;B -&gt; C [
shape=box ]&#64;.</p></li>
<li><p>Note that all of the above is still yaml syntax, the outer parser
only adds additional interpretation (post-processing) of &#64;Include,
Edit, Delete&#64; tags, &#64;&lt;..&gt;&#64; values, and &#64;(..)&#64; in names.</p></li>
</ul>
<p>Within rai, .g-files are used to represent parameter files, robotic
configurations (<span class="math notranslate nohighlight">\(\sim\)</span> URDF), 1st order logic, factor graphs,
optimization problems. The underlying data structure is used, e.g., as
any-type container, Graph, or auto-convertion to python dictionaries.</p>
<p>Subgraphs may contain nodes that have parents from the containing graph,
or from other subgraphs of the containing graph. Some methods of the
<code class="docutils literal notranslate"><span class="pre">Graph</span></code> class (to find nodes by key or type) allow to specify whether
also nodes in subgraphs or parentgraphs are to be searched. This
connectivity across (sub)-graphs e.g. allows to represent logic
knowledge bases.</p>
<p>The Editing Configurations tutorial
&lt;<a class="reference external" href="https://marctoussaint.github.io/robotic/tutorials/config_3_import_edit.html">https://marctoussaint.github.io/robotic/tutorials/config_3_import_edit.html</a>&gt;
shows this file syntax is used to specify robot/environment
configurations.</p>
</section>
</section>
<section id="cameras">
<h2>Cameras<a class="headerlink" href="#cameras" title="Link to this heading"></a></h2>
<section id="image-camera-world-coordinates">
<h3>Image, Camera, &amp; World Coordinates<a class="headerlink" href="#image-camera-world-coordinates" title="Link to this heading"></a></h3>
<p>In this section, we use the following notation for coordinates of a 3D
point:</p>
<ul class="simple">
<li><p>world coordinates <span class="math notranslate nohighlight">\(X\)</span>,</p></li>
<li><p>camera coordinates <span class="math notranslate nohighlight">\(x\)</span> (so that <span class="math notranslate nohighlight">\(X = T x\)</span>, where
<span class="math notranslate nohighlight">\(T\equiv T_{W\to C}\)</span> is the camera position/orientation, also
called <strong>extrinsic parameter</strong>),</p></li>
<li><p>image coordinates <span class="math notranslate nohighlight">\(u=(u_x,u_y,u_z)\)</span>, with the pixel coordinates
<span class="math notranslate nohighlight">\((u_x,u_y)\)</span> and depth coordinate <span class="math notranslate nohighlight">\(u_z\)</span>, details as
followed.</p></li>
</ul>
<p>The pixel coordinates <span class="math notranslate nohighlight">\((u_x,u_y)\)</span> indicate where a point appears
on the image plane. The <span class="math notranslate nohighlight">\(x\)</span>-axis always points to the right, but
there are two conventions for the <span class="math notranslate nohighlight">\(y\)</span>-axis:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(y\)</span>-up: The <span class="math notranslate nohighlight">\(y\)</span>-axis points upward. This is consistent to
how a diagram is typically drawn on paper: <span class="math notranslate nohighlight">\(x\)</span>-axis right,
<span class="math notranslate nohighlight">\(y\)</span>-axis up. However, a consequence is that the <span class="math notranslate nohighlight">\(z\)</span>-axis
then points backward, i.e., pixels in front of the camera have
negative depth <span class="math notranslate nohighlight">\(u_z\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(y\)</span>-down: The <span class="math notranslate nohighlight">\(y\)</span>-axis points down. This is consistent to
how pixels are typically indexed in image data: counting rows from
top to bottom. So when defining pixel coordinates <span class="math notranslate nohighlight">\((u_x,u_y)\)</span>
literally to be pixel indices in image data, <span class="math notranslate nohighlight">\(y\)</span>-down is the
natural convention. A consequence is that the <span class="math notranslate nohighlight">\(z\)</span>-axis points
forward, i.e., pixels in front of the camera have a positive depth
<span class="math notranslate nohighlight">\(u_z\)</span>, which might also be more intuitive.</p></li>
</ul>
<p>The transformation from camera coordinates <span class="math notranslate nohighlight">\(x\)</span> to image
coordinates <span class="math notranslate nohighlight">\(u\)</span> is involves perspective projection. For better
readability, let’s write
<span class="math notranslate nohighlight">\(x \equiv (\texttt{x},\texttt{y},\texttt{z})\)</span>. Then the mapping is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\label{eqxtou}
u =  \left(\begin{array}{c}u_x \\ u_y \\ u_z\end{array}\right)
&amp;=  \left(\begin{array}{c}(f_x \texttt{x}+ s \texttt{y})/\texttt{z}+ c_x\\ f_y \texttt{y}/\texttt{z}+ c_y \\ \texttt{z}\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Here, the five so-called <strong>intrinsic parameters</strong>
<span class="math notranslate nohighlight">\(f_x,f_y,c_x,c_y,s\)</span> are the focal length <span class="math notranslate nohighlight">\(f_x,f_y\)</span>, the
image center <span class="math notranslate nohighlight">\(c_x,c_y\)</span>, and a image skew <span class="math notranslate nohighlight">\(s\)</span> (which is
usually zero). E.g., for an image of height <span class="math notranslate nohighlight">\(H\)</span> and width
<span class="math notranslate nohighlight">\(W\)</span>, and vertical full view angle <span class="math notranslate nohighlight">\(\alpha\)</span>, we typically
have an image center <span class="math notranslate nohighlight">\(c_x \approx H/2, c_y \approx W/2\)</span> and a
focal length <span class="math notranslate nohighlight">\(f_y
= \frac{H}{2 \tan(\alpha/2)}\)</span>, e.g., for <span class="math notranslate nohighlight">\(\alpha=90^\circ\)</span>,
<span class="math notranslate nohighlight">\(f_y = H/2\)</span>. For a typical camera <span class="math notranslate nohighlight">\(f_x \approx f_y\)</span>.</p>
<p>Inversely, if we have image coordinates <span class="math notranslate nohighlight">\(u\)</span> and want to convert to
cartesian camera coordinates, we have (assuming <span class="math notranslate nohighlight">\(s=0\)</span>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
x
&amp;=  \left(\begin{array}{c}(u_x - c_x) u_z / f_x\\ (u_y - c_y) u_z / f_y \\ u_z\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
</section>
<section id="homogeneous-coordinates-camera-matrix-p">
<h3>Homogeneous coordinates &amp; Camera Matrix <span class="math notranslate nohighlight">\(P\)</span><a class="headerlink" href="#homogeneous-coordinates-camera-matrix-p" title="Link to this heading"></a></h3>
<p>First a brief definition: <em>A homogeneous coordinate
:math:`boldsymbol x=(x_1,..,x_n,w)` is a (redundant) description of the
:math:`n`-dim point</em></p>
<div class="math notranslate nohighlight">
\[\begin{split}{\cal P}(\boldsymbol x)=  \left(\begin{array}{c}x_1/w \\ \vdots \\ x_n/w\end{array}\right)  ~.\end{split}\]</div>
<p>Note that two coordinates <span class="math notranslate nohighlight">\((x_1,..,x_n,w)\)</span> and
<span class="math notranslate nohighlight">\((\lambda x_1,..,\lambda x_n,\lambda w)\)</span> are “equivalent” in that
they describe the same point. The operation <span class="math notranslate nohighlight">\({\cal P}\)</span> is
<em>non-linear</em> and called <strong>perspective projection</strong>. In this section, we
write homogeneous coordinates in bold <span class="math notranslate nohighlight">\(\boldsymbol x\)</span>.</p>
<p>Back to our camera setting: Let <span class="math notranslate nohighlight">\(\boldsymbol x\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol X\)</span> be homogeneous camera and world coordinates of a
point (typically both have <span class="math notranslate nohighlight">\(w=1\)</span> as last entry). Then the pose
transformation <span class="math notranslate nohighlight">\(T\)</span> can be written as <span class="math notranslate nohighlight">\(4\times\)</span> matrix such
that</p>
<div class="math notranslate nohighlight">
\[\boldsymbol x = T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} \boldsymbol X ~.\]</div>
<p>Given camera coordinates
<span class="math notranslate nohighlight">\(x \equiv (\texttt{x},\texttt{y},\texttt{z})\)</span>, we can write
([eqxtou])</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol u
&amp;= K x
=  \left(\begin{array}{c}f_x \texttt{x}+ s \texttt{y}+ c_x \texttt{z}\\ f_y \texttt{y}+ c_y \texttt{z}\\ \texttt{z}\end{array}\right)  ~,\quad
K =  \left(\begin{array}{ccc}f_x &amp; s &amp; c_x \\ &amp; f_y &amp; c_y \\ &amp; &amp; 1 \end{array}\right)  ~,\quad
{\cal P}(\boldsymbol u)
=  \left(\begin{array}{c}  (f_x x + s \texttt{y})/\texttt{z}+ c_x\\ f_y \texttt{y}/\texttt{z}+ c_y \end{array}\right)  ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol u\)</span> are <em>homogeneous pixel</em> coordinates, and
<span class="math notranslate nohighlight">\({\cal P}(\boldsymbol u)\)</span> the actual pixel coordinates, which
would have to be augmented with <span class="math notranslate nohighlight">\(\texttt{z}\)</span> again to get the
<span class="math notranslate nohighlight">\(u\)</span> including depth coordinate.</p>
<p>The <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix <span class="math notranslate nohighlight">\(K\)</span> includes the 5 general intrinsic
parameters. Writing the inverse transformation
<span class="math notranslate nohighlight">\(T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span> as a
<span class="math notranslate nohighlight">\(3\times 4\)</span> matrix
<span class="math notranslate nohighlight">\(\left(\begin{array}{cc}R^{\!\top\!}&amp; -R^{\!\top\!}t\end{array}\right)\)</span>
with rotation <span class="math notranslate nohighlight">\(R\)</span> and translation <span class="math notranslate nohighlight">\(t\)</span>, we can write the
relation between <span class="math notranslate nohighlight">\(\boldsymbol u\)</span> and homogeneous world coordinates
<span class="math notranslate nohighlight">\(\boldsymbol X\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol u = P \boldsymbol X
~,\quad\text{with~} P =  \left(\begin{array}{cc}K &amp; 0\end{array}\right) ~ T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} =  \left(\begin{array}{cc}K &amp; 0\end{array}\right) ~  \left(\begin{array}{cc}R^{\!\top\!}&amp; -R^{\!\top\!}t \\ &amp; 1\end{array}\right)  =  \left(\begin{array}{cc}KR^{\!\top\!}&amp; -KR^{\!\top\!}t\end{array}\right)  ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(P\)</span> is the <span class="math notranslate nohighlight">\(3\times 4\)</span> <strong>camera matrix</strong>, which
subsumes 5 intrinsic and 6 extrinsic (3 rotation, 3 translation)
parameters. Except for absolute scaling (the 1 in the definition of
<span class="math notranslate nohighlight">\(K\)</span>), this fully parameterizes a general affine transform.</p>
</section>
<section id="calibration-as-estimating-p-k-r-t-from-depth-data">
<h3>Calibration as Estimating <span class="math notranslate nohighlight">\(P,K,R,t\)</span> from Depth Data<a class="headerlink" href="#calibration-as-estimating-p-k-r-t-from-depth-data" title="Link to this heading"></a></h3>
<p>Assuming we have data of pairs <span class="math notranslate nohighlight">\((\boldsymbol u, \boldsymbol X)\)</span>,
we can use the basic equation <span class="math notranslate nohighlight">\(\boldsymbol u = P \boldsymbol X\)</span> to
retrieve <span class="math notranslate nohighlight">\(P\)</span> in closed from, and in a second step retrieve the
intrinsic and extrinsic camera parameters from <span class="math notranslate nohighlight">\(P\)</span>. Note that here
we discuss the situation where we have the “right” <span class="math notranslate nohighlight">\(\boldsymbol u\)</span>
in the data – and not only the pixel coordinates
<span class="math notranslate nohighlight">\({\cal P}(\boldsymbol u)\)</span>! This means that we assume we have data
entries <span class="math notranslate nohighlight">\(\boldsymbol u = (u_x u_z, u_y u_z, u_z)\)</span> which includes
the true depth <span class="math notranslate nohighlight">\(u_z\)</span>. So this method is only applicable when we
want to calibrate a depth camera.</p>
<p>Given data <span class="math notranslate nohighlight">\(D = \{(\boldsymbol u_i, \boldsymbol X_i)\}_{i=1}^n\)</span>,
we want to minimize the squared error</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\text{argmin}_P \sum_i (\boldsymbol u_i - P \boldsymbol X_i)^2 = [U - P X]^2 ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(X\)</span> are the stacked <span class="math notranslate nohighlight">\(\boldsymbol u_i\)</span>
and <span class="math notranslate nohighlight">\(\boldsymbol X_i\)</span>, respectively. The solution is
<span class="math notranslate nohighlight">\(P = U^{\!\top\!}X (X^{\!\top\!}X)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>.
Comparing with the definition
<span class="math notranslate nohighlight">\(P=  \left(\begin{array}{cc}KR^{\!\top\!}&amp; -KR^{\!\top\!}t\end{array}\right)\)</span>,
we can decompose it and extract explicit <span class="math notranslate nohighlight">\(K, R, t\)</span> using</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  (K,R^{\!\top\!}) &amp;\gets \text{RQ-decomposition}(P_{1:3,:}) \\
  t &amp;\gets -(K R^{\!\top\!})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} P_{4,:}\end{aligned}\end{split}\]</div>
<p>However, when defining
<span class="math notranslate nohighlight">\(\bar u = (\boldsymbol u,1) = (u_x u_z, u_y u_z, u_z, 1)\)</span> (with
additional 1 agumented), we can also write the inverse linear relation
to the non-homogeneous world coordinate <span class="math notranslate nohighlight">\(X\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
X  = P^+ \bar u~,\quad\text{with~} P^+ =  \left(\begin{array}{cc}R K^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} &amp; t\end{array}\right)  \bar u~,\end{aligned}\]</div>
<p>Using data <span class="math notranslate nohighlight">\(X\)</span> (<span class="math notranslate nohighlight">\(3\times n\)</span>) and <span class="math notranslate nohighlight">\(U\)</span>
(<span class="math notranslate nohighlight">\(4\times n\)</span>) the optimum is
<span class="math notranslate nohighlight">\(P^+ = X^{\!\top\!}U (U^{\!\top\!}U)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>.
We can decompose it using</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  t &amp;\gets P^+_{3,:} \\
  (K,R^{\!\top\!}) &amp;\gets \text{RQ-decomposition}( [P^+_{1:3,:}]^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} ]\end{aligned}\end{split}\]</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../tutorials/ext_gym_environment.html" class="btn btn-neutral float-left" title="Extension - Gym Environment Interface: minimal example" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../api.html" class="btn btn-neutral float-right" title="robotic python API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Marc Toussaint.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>